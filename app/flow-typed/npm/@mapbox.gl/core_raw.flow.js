/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 * @flow
 */

declare module "@deck.gl/core/utils/log" {
  declare var _default: any;
  declare export default typeof _default;
}

declare module "@deck.gl/core/debug/loggers" {
  declare export var getLoggers: (
    log: any
  ) => {
    "layer.changeFlag": (layer: any, key: any, flags: any) => void,
    "layer.initialize": (layer: any) => void,
    "layer.update": (layer: any, needsUpdate: any) => void,
    "layer.matched": (layer: any, changed: any) => void,
    "layer.finalize": (layer: any) => void,
    "compositeLayer.renderLayers": (
      layer: any,
      updated: any,
      subLayers: any
    ) => void,
    "layerManager.setLayers": (
      layerManager: any,
      updated: any,
      layers: any
    ) => void,
    "layerManager.activateViewport": (layerManager: any, viewport: any) => void,
    "attributeManager.invalidate": (
      attributeManager: any,
      trigger: any,
      attributeNames: any
    ) => void,
    "attributeManager.updateStart": (attributeManager: any) => void,
    "attributeManager.updateEnd": (
      attributeManager: any,
      numInstances: any
    ) => void,
    "attribute.updateStart": (attribute: any) => void,
    "attribute.allocate": (attribute: any, numInstances: any) => void,
    "attribute.updateEnd": (attribute: any, numInstances: any) => void,
    "deckRenderer.renderLayers": (
      deckRenderer: any,
      renderStats: any,
      opts: any
    ) => void,
    ...
  };
}

declare module "debug" {
  declare export function register(handlers: any): void;

  declare export default function debug(eventType: any): void;
}

declare module "@deck.gl/core/utils/json-loader" {
  declare function isJSON(text: any): boolean;

  declare var _default: {
    name: string,
    extensions: string[],
    testText: typeof isJSON,
    parseTextSync: (
      text: string,
      reviver?: (key: string, value: any) => any
    ) => any,
    ...
  };
  declare export default typeof _default;
}

declare module "@deck.gl/core/lib/init" {
  declare var _default: any;
  declare export default typeof _default;
}

declare module "@deck.gl/core/shaderlib/misc/geometry" {
  declare var _default: {
    name: string,
    vs: string,
    fs: string,
    ...
  };
  declare export default typeof _default;
}

declare module "@deck.gl/core/lib/constants" {
  declare export var COORDINATE_SYSTEM: {
    DEFAULT: number,
    LNGLAT: number,
    METER_OFFSETS: number,
    LNGLAT_OFFSETS: number,
    CARTESIAN: number,
    ...
  };
  declare export var PROJECTION_MODE: {
    WEB_MERCATOR: number,
    WEB_MERCATOR_AUTO_OFFSET: number,
    IDENTITY: number,
    ...
  };
  declare export var EVENTS: {
    click: {
      handler: string,
      ...
    },
    panstart: {
      handler: string,
      ...
    },
    panmove: {
      handler: string,
      ...
    },
    panend: {
      handler: string,
      ...
    },
    ...
  };
}

declare module "@deck.gl/core/utils/memoize" {
  /**
   * Speed up consecutive function calls by caching the result of calls with identical input
   * https://en.wikipedia.org/wiki/Memoization
   * @param {function} compute - the function to be memoized
   */
  declare export default function memoize(compute: any): (args: any) => any;
}

declare module "@deck.gl/core/utils/assert" {
  declare export default function assert(condition: any, message: any): void;
}

declare module "@deck.gl/core/shaderlib/project/viewport-uniforms" {
  declare export function getOffsetOrigin(
    viewport: any,
    coordinateSystem: any,
    coordinateOrigin?: number[]
  ): {
    geospatialOrigin: any,
    shaderCoordinateOrigin: number[],
    offsetMode: boolean,
    ...
  };

  /**
   * Returns uniforms for shaders based on current projection
   * includes: projection matrix suitable for shaders
   *
   * TODO - Ensure this works with any viewport, not just WebMercatorViewports
   * @param {WebMercatorViewport} viewport -
   * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
   */
  declare export function getUniformsFromViewport(x?: {
    viewport: any,
    devicePixelRatio?: number,
    modelMatrix?: any,
    coordinateSystem?: number,
    coordinateOrigin: number[],
    wrapLongitude?: boolean,
    projectionMode: any,
    positionOrigin: any,
    ...
  }): any;
}

declare module "@deck.gl/core/shaderlib/project/project" {
  declare function getUniforms(opts?: { ... }): any;

  declare var _default: {
    name: string,
    dependencies: any[],
    vs: string,
    getUniforms: typeof getUniforms,
    ...
  };
  declare export default typeof _default;
}

declare module "@deck.gl/core/shaderlib/project32/project32" {
  declare var _default: {
    name: string,
    dependencies: {
      name: string,
      dependencies: any[],
      vs: string,
      getUniforms: (opts?: { ... }) => any,
      ...
    }[],
    vs: string,
    ...
  };
  declare export default typeof _default;
}

declare module "@deck.gl/core/shaderlib/shadow/shadow" {
  declare var _default: {
    name: string,
    dependencies: {
      name: string,
      dependencies: any[],
      vs: string,
      getUniforms: (opts?: { ... }) => any,
      ...
    }[],
    vs: string,
    fs: string,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": string,
      "fs:DECKGL_FILTER_COLOR": string,
      ...
    },
    getUniforms: (opts?: { ... }, context?: { ... }) => { ... },
    ...
  };
  declare export default typeof _default;
}

declare module "@deck.gl/core/shaderlib/picking/picking" {
  declare var _default: any;
  declare export default typeof _default;
}

declare module "@deck.gl/core/shaderlib" {
  import typeof { gouraudLighting, phongLighting } from "@luma.gl/core";

  import typeof project from "@deck.gl/core/shaderlib/project/project";

  import typeof project32 from "@deck.gl/core/shaderlib/project32/project32";

  import typeof shadow from "@deck.gl/core/shaderlib/shadow/shadow";

  import typeof picking from "@deck.gl/core/shaderlib/picking/picking";

  declare export function createProgramManager(gl: any): any;

  declare export {
    picking,
    project,
    project32,
    gouraudLighting,
    phongLighting,
    shadow,
  };
}

declare module "@deck.gl/core/effects/lighting/ambient-light" {
  declare export class AmbientLight {
    constructor(props?: { ... }): this;
  }
}

declare module "@deck.gl/core/effects/lighting/directional-light" {
  declare export class DirectionalLight {
    constructor(props?: { ... }): this;
    getProjectedLight(l?: {
      layer: any,
      ...
    }): this;
  }
}

declare module "@deck.gl/core/lib/effect" {
  declare export default class Effect {
    constructor(props?: { ... }): this;
    preRender(...params: any[]): void;
    getModuleParameters(layer?: any): void;
    cleanup(): void;
  }
}

declare module "@deck.gl/core/passes/pass" {
  declare export default class Pass {
    constructor(gl: any, props?: { ... }): this;
    setProps(props: any): void;
    render(params?: any): any[] | void;
    cleanup(): void;
  }
}

declare module "@deck.gl/core/passes/layers-pass" {
  import typeof Pass from "@deck.gl/core/passes/pass";

  declare export default class LayersPass mixins Pass {
    render(props: any): any[] | void;
    _drawLayers(props: any): any[];
    _drawLayersInViewport(
      gl: any,
      x: {
        layers: any,
        layerFilter: any,
        onError: any,
        viewport: any,
        view: any,
        pass?: string,
        effects: any,
        moduleParameters: any,
        ...
      }
    ): {
      totalCount: any,
      visibleCount: number,
      compositeCount: number,
      pickableCount: number,
      ...
    };
    shouldDrawLayer(layer: any): boolean;
    getModuleParameters(layer: any, effects: any): any;
    getLayerParameters(layer: any, layerIndex: any): any;
    _shouldDrawLayer(
      layer: any,
      viewport: any,
      pass: any,
      layerFilter: any
    ): any;
    _getModuleParameters(
      layer: any,
      effects: any,
      pass: any,
      overrides: any
    ): any;
  }
  declare export function layerIndexResolver(
    startIndex?: number,
    layerIndices?: { ... }
  ): (layer: any, isDrawn: any) => any;
}

declare module "@deck.gl/core/passes/shadow-pass" {
  import type { default as LayersPass } from "@deck.gl/core/passes/layers-pass";

  declare export default class ShadowPass mixins LayersPass {
    constructor(gl: any, props: any): this;
    render(params: any): void;
    shouldDrawLayer(layer: any): boolean;
    getModuleParameters(): {
      drawToShadowMap: boolean,
      ...
    };
    delete(): void;
  }
}

declare module "@deck.gl/core/effects/lighting/lighting-effect" {
  import typeof Effect from "@deck.gl/core/lib/effect";

  declare export default class LightingEffect mixins Effect {
    constructor(props: any): this;
    preRender(
      gl: any,
      x: {
        layers: any,
        layerFilter: any,
        viewports: any,
        onViewportActive: any,
        views: any,
        ...
      }
    ): void;
    getModuleParameters(
      layer: any
    ):
      | {
          shadowMaps: any,
          dummyShadowMap: any,
          shadowColor: any,
          shadowMatrices: any,
          ...
        }
      | {
          shadowMaps?: void,
          dummyShadowMap?: void,
          shadowColor?: void,
          shadowMatrices?: void,
          ...
        };
    cleanup(): void;
    _createLightMatrix(): any[];
    _createShadowPasses(gl: any): void;
    _applyDefaultLights(): void;
  }
}

declare module "@deck.gl/core/shaderlib/project/project-functions" {
  import type { Position } from "@deck.gl/core/utils/positions";

  declare export function getWorldPosition(
    position: Position,
    x: {
      viewport: any,
      modelMatrix: any,
      coordinateSystem: any,
      coordinateOrigin: any,
      offsetMode: any,
      ...
    }
  ): any;

  /**
 * Equivalent to project_position in project.glsl
 * projects a user supplied position to world position directly with or without
 * a reference coordinate system
 * @param {array} position - [x, y, z]
 * @param {object} params
 * @param {Viewport} params.viewport - the current viewport
 * @param {number} params.coordinateSystem - the reference coordinate system used
align world position
 * @param {array} params.coordinateOrigin - the reference coordinate origin used
to align world position
 * @param {Matrix4} [params.modelMatrix] - the model matrix of the supplied position
 * @param {number} [params.fromCoordinateSystem] - the coordinate system that the
supplied position is in. Default to the same as `coordinateSystem`.
 * @param {array} [params.fromCoordinateOrigin] - the coordinate origin that the
supplied position is in. Default to the same as `coordinateOrigin`.
 */
  declare export function projectPosition(position: any, params: any): any;
}

declare module "@deck.gl/core/lib/attribute/shader-attribute" {
  declare export default class ShaderAttribute {
    constructor(dataColumn: any, opts: any): this;
    value: any;
    getValue(): any;
    getAccessor(): any;
  }
}

declare module "@deck.gl/core/lib/attribute/gl-utils" {
  declare export function glArrayFromType(
    glType: any
  ):
    | Float32ArrayConstructor
    | Float64ArrayConstructor
    | Uint16ArrayConstructor
    | Uint32ArrayConstructor
    | Uint8ClampedArrayConstructor
    | Int8ArrayConstructor
    | Int16ArrayConstructor
    | Int32ArrayConstructor;
}

declare module "@deck.gl/core/utils/typed-array-manager" {
  declare export class TypedArrayManager {
    constructor(x?: {
      overAlloc?: number,
      poolSize?: number,
      ...
    }): this;
    allocate(
      typedArray: any,
      count: any,
      x: {
        size?: number,
        type: any,
        padding?: number,
        copy?: boolean,
        ...
      }
    ): any;
    release(typedArray: any): void;
    _allocate(Type: any, size: any): any;
    _release(typedArray: any): void;
  }
  declare var _default: TypedArrayManager;
  declare export default typeof _default;
}

declare module "@deck.gl/core/utils/math-utils" {
  declare export function createMat4(): number[];

  declare export function mod(value: any, divisor: any): any;

  declare export function extractCameraVectors(x: {
    viewMatrix: any,
    viewMatrixInverse: any,
    ...
  }): {
    eye: any[],
    direction: number[],
    up: any[],
    right: any[],
    ...
  };

  declare export function getFrustumPlanes(x: {
    aspect: any,
    near: any,
    far: any,
    fovyRadians: any,
    position: any,
    direction: any,
    up: any,
    right: any,
    ...
  }): {
    near: {
      distance: any,
      normal: any,
      ...
    },
    far: {
      distance: any,
      normal: any,
      ...
    },
    ...
  };

  /**
   * Calculate the low part of a WebGL 64 bit float
   * @param {number} x - the input float number
   * @returns {number} - the lower 32 bit of the number
   */
  declare export function fp64LowPart(x: any): number;

  /**
 * Split a Float64Array into a double-length Float32Array
 * @param {Float64Array} typedArray
 * @param {Number} size - per attribute size
 * @param {Number} [startIndex] - start index in the source array
 * @param {Number} [endIndex] - end index in the source array
 * @returns {Float32Array} - high part, low part for each attribute:
[1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]
 */
  declare export function toDoublePrecisionArray(
    typedArray: any,
    x: {
      size?: number,
      startIndex?: number,
      endIndex: any,
      ...
    }
  ): any;
}

declare module "@deck.gl/core/lib/attribute/data-column" {
  declare export default class DataColumn {
    constructor(gl: any, opts: any): this;
    buffer: any;
    byteOffset: number;
    delete(): void;
    getShaderAttributes(id: any, options: any): { ... };
    getBuffer(): any;
    getValue(): any;
    getAccessor(): any;
    setData(opts: any): boolean;
    updateSubBuffer(opts?: { ... }): void;
    allocate(x: {
      numInstances: any,
      copy?: boolean,
      ...
    }): boolean;
    _checkExternalBuffer(opts: any): void;
    _normalizeConstant(value: any): any;
    _normalizeValue(value: any, out: any, start: any): any;
    _areValuesEqual(value1: any, value2: any): boolean;
  }
}

declare module "@deck.gl/core/utils/iterable-utils" {
  declare export function createIterable(
    data: any,
    startRow?: number,
    endRow?: number
  ): {
    iterable: any[],
    objectInfo: {
      index: number,
      data: any,
      target: any[],
      ...
    },
    ...
  };

  declare export function isAsyncIterable(data: any): any;

  declare export function getAccessorFromBuffer(
    typedArray: any,
    x: {
      size: any,
      stride: any,
      offset: any,
      startIndices: any,
      nested: any,
      ...
    }
  ): (
    _: any,
    x: {
      index: any,
      target: any,
      ...
    }
  ) => any;
}

declare module "@deck.gl/core/utils/flatten" {
  /**
 * Flattens a nested array into a single level array,
 * or a single value into an array with one value
 * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
 * @example flatten(1) => [1]
 * @param {Array} array The array to flatten.
 * @param {Function} filter = - Optional predicate called on each `value` to
determine if it should be included (pushed onto) the resulting array.
 * @param {Function} map = - Optional transform applied to each array elements.
 * @param {Array} result =[] - Optional array to push value into
 * @return {Array} Returns the new flattened array (new array or `result` if provided)
 */
  declare export function flatten(array: any, filter?: () => boolean): any;

  declare export function fillArray(x: {
    target: any,
    source: any,
    start?: number,
    count?: number,
    ...
  }): any;
}

declare module "@deck.gl/core/utils/range" {
  declare export var EMPTY: any[];
  declare export var FULL: number[][];
  declare export function add(rangeList: any, range: any): any;
}

declare module "@deck.gl/core/utils/array-utils" {
  declare export function padArray(x: {
    source: any,
    target: any,
    size: any,
    getData: any,
    sourceStartIndices: any,
    targetStartIndices: any,
    ...
  }): any;
}

declare module "@deck.gl/core/lib/attribute/attribute-transition-utils" {
  declare export function normalizeTransitionSettings(
    userSettings: any,
    layerSettings: any
  ): any;

  declare export function getSourceBufferAttribute(
    gl: any,
    attribute: any
  ): any;

  declare export function getAttributeTypeFromSize(
    size: any
  ): "float" | "vec2" | "vec3" | "vec4";

  declare export function cycleBuffers(buffers: any): void;

  declare export function getAttributeBufferLength(
    attribute: any,
    numInstances: any
  ): number;

  declare export function padBuffer(x: {
    buffer: any,
    numInstances: any,
    attribute: any,
    fromLength: any,
    fromStartIndices: any,
    getData?: (x: any) => any,
    ...
  }): void;
}

declare module "@deck.gl/core/lib/attribute/attribute" {
  import typeof DataColumn from "@deck.gl/core/lib/attribute/data-column";

  declare export default class Attribute mixins DataColumn {
    constructor(gl: any, opts?: { ... }): this;
    startIndices: any;
    -startIndices: any;
    needsUpdate(): any;
    needsRedraw(x?: {
      clearChangedFlags?: boolean,
      ...
    }): any;
    getUpdateTriggers(): any[];
    supportsTransition(): boolean;
    getTransitionSetting(opts: any): any;
    setNeedsUpdate(reason: any, dataRange: any): void;
    clearNeedsUpdate(): void;
    setNeedsRedraw(reason?: any): void;
    update(opts: any): void;
    allocate(numInstances: any): boolean;
    updateBuffer(x: {
      numInstances: any,
      data: any,
      props: any,
      context: any,
      ...
    }): boolean;
    setConstantValue(value: any): boolean;
    setExternalBuffer(buffer: any): boolean;
    setBinaryValue(buffer: any, startIndices?: any): boolean;
    getVertexOffset(row: any): number;
    getShaderAttributes(): { ... };
    _autoUpdater(
      attribute: any,
      x: {
        data: any,
        startRow: any,
        endRow: any,
        props: any,
        numInstances: any,
        ...
      }
    ): void;
    _validateAttributeUpdaters(): void;
    _checkAttributeArray(): void;
  }
}

declare module "@deck.gl/core/transitions/transition" {
  declare export default class Transition {
    /**
     * @params timeline {Timeline}
     */
    constructor(timeline: any): this;
    inProgress: any;

    /**
     * (re)start this transition.
     * @params props {object} - optional overriding props. see constructor
     */
    start(props: any): void;

    /**
     * end this transition if it is in progress.
     */
    end(): void;

    /**
     * cancel this transition if it is in progress.
     */
    cancel(): void;

    /**
     * update this transition. Returns `true` if updated.
     */
    update(): boolean;
    _onUpdate(): void;
  }
}

declare module "@deck.gl/core/transitions/gpu-interpolation-transition" {
  declare export default class GPUInterpolationTransition {
    constructor(x: {
      gl: any,
      attribute: any,
      timeline: any,
      ...
    }): this;
    inProgress: any;
    start(transitionSettings: any, numInstances: any): void;
    update(): any;
    cancel(): void;
  }
}

declare module "@deck.gl/core/transitions/gpu-spring-transition" {
  declare export default class GPUSpringTransition {
    constructor(x: {
      gl: any,
      attribute: any,
      timeline: any,
      ...
    }): this;
    inProgress: any;
    start(transitionSettings: any, numInstances: any): void;
    update(): boolean;
    cancel(): void;
  }
}

declare module "@deck.gl/core/lib/attribute/attribute-transition-manager" {
  declare export default class AttributeTransitionManager {
    constructor(
      gl: any,
      x: {
        id: any,
        timeline: any,
        ...
      }
    ): this;
    finalize(): void;
    update(x: {
      attributes: any,
      transitions?: { ... },
      numInstances: any,
      ...
    }): void;
    hasAttribute(attributeName: any): any;
    getAttributes(): { ... };
    run(): any;
    _removeTransition(attributeName: any): void;
    _updateAttribute(attributeName: any, attribute: any, settings: any): void;
  }
}

declare module "@deck.gl/core/lib/attribute/attribute-manager" {
  import typeof Attribute from "@deck.gl/core/lib/attribute/attribute";

  declare export default class AttributeManager {
    /**
 * @classdesc Automated attribute generation and management. Suitable when a set of
vertex shader attributes are generated by iteration over a data array,
and updates to these attributes are needed either when the data itself
changes, or when other data relevant to the calculations change.

- First the application registers descriptions of its dynamic vertex
  attributes using AttributeManager.add().
- Then, when any change that affects attributes is detected by the
  application, the app will call AttributeManager.invalidate().
- Finally before it renders, it calls AttributeManager.update() to
  ensure that attributes are automatically rebuilt if anything has been
  invalidated.

The application provided update functions describe how attributes
should be updated from a data array and are expected to traverse
that data array (or iterable) and fill in the attribute's typed array.

Note that the attribute manager intentionally does not do advanced
change detection, but instead makes it easy to build such detection
by offering the ability to "invalidate" each attribute separately.
 */
    constructor(
      gl: any,
      x?: {
        id?: string,
        stats: any,
        timeline: any,
        ...
      }
    ): this;
    finalize(): void;
    getNeedsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): any;
    setNeedsRedraw(redraw?: boolean): this;
    add(attributes: any, updaters: any): void;
    addInstanced(attributes: any, updaters: any): void;

    /**
     * Removes attributes
     * Takes an array of attribute names and delete them from
     * the attribute map if they exists
     * @example attributeManager.remove(['position']);
     * @param {Object} attributeNameArray - attribute name array (see above)
     */
    remove(attributeNameArray: any): void;
    invalidate(triggerName: any, dataRange: any): void;
    invalidateAll(dataRange: any): void;
    update(x?: {
      data: any,
      numInstances: any,
      startIndices?: any,
      transitions: any,
      props?: { ... },
      buffers?: { ... },
      context?: { ... },
      ...
    }): void;
    updateTransition(): any;

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */
    getAttributes(): any;

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuffers need to be updated
     * @return {Object} attributes - descriptors
     */
    getChangedAttributes(opts?: {
      clearChangedFlags: boolean,
      ...
    }): any;
    getShaderAttributes(attributes: any, excludeAttributes?: { ... }): { ... };
    getAccessors(): any;
    _add(attributes: any, updaters: any, extraProps?: { ... }): void;
    _createAttribute(name: any, attribute: any, extraProps: any): Attribute;
    _mapUpdateTriggersToAttributes(): void;
    _invalidateTrigger(triggerName: any, dataRange: any): any;
    _updateAttribute(opts: any): void;
  }
}

declare module "@deck.gl/core/transitions/cpu-interpolation-transition" {
  import typeof Transition from "@deck.gl/core/transitions/transition";

  declare export default class CPUInterpolationTransition mixins Transition {
    value: any;
    _onUpdate(): void;
  }
}

declare module "@deck.gl/core/transitions/cpu-spring-transition" {
  import typeof Transition from "@deck.gl/core/transitions/transition";

  declare export default class CPUSpringTransition mixins Transition {
    value: any;
    _onUpdate(): void;
  }
}

declare module "@deck.gl/core/lib/uniform-transition-manager" {
  declare export default class UniformTransitionManager {
    constructor(timeline: any): this;
    active: boolean;
    add(key: any, fromValue: any, toValue: any, settings: any): void;
    remove(key: any): void;
    update(): { ... };
    clear(): void;
  }
}

declare module "@deck.gl/core/lifecycle/constants" {
  declare export var LIFECYCLE: {
    NO_STATE: string,
    MATCHED: string,
    INITIALIZED: string,
    AWAITING_GC: string,
    AWAITING_FINALIZATION: string,
    FINALIZED: string,
    ...
  };
  declare export var PROP_SYMBOLS: {
    COMPONENT: Symbol,
    ASYNC_DEFAULTS: Symbol,
    ASYNC_ORIGINAL: Symbol,
    ASYNC_RESOLVED: Symbol,
    ...
  };
}

declare module "@deck.gl/core/lifecycle/props" {
  declare export function validateProps(props: any): void;

  declare export function diffProps(
    props: any,
    oldProps: any
  ): {
    dataChanged: any,
    propsChanged: string,
    updateTriggersChanged: boolean,
    extensionsChanged: string | boolean,
    transitionsChanged: { ... },
    ...
  };

  /**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * @param {Object} opt.oldProps - object with old key/value pairs
 * @param {Object} opt.newProps - object with new key/value pairs
 * @param {Object} opt.ignoreProps ={} - object, keys that should not be compared
 * @returns {null | String} - null when values of all keys are strictly equal.
if unequal, returns a string explaining what changed.
 */
  declare export function compareProps(x?: {
    newProps: any,
    oldProps: any,
    ignoreProps?: { ... },
    propTypes?: { ... },
    triggerName?: string,
    ...
  }): string;
}

declare module "@deck.gl/core/utils/count" {
  /**
   * Deduces numer of elements in a JavaScript container.
   * - Auto-deduction for ES6 containers that define a count() method
   * - Auto-deduction for ES6 containers that define a size member
   * - Auto-deduction for Classic Arrays via the built-in length attribute
   * - Also handles objects, although note that this an O(N) operation
   */
  declare export function count(container: any): any;
}

declare module "@deck.gl/core/utils/shader" {
  declare export function mergeShaders(target: any, source: any): any;
}

declare module "@deck.gl/core/lifecycle/prop-types" {
  declare export function parsePropTypes(
    propDefs: any
  ): {
    propTypes: { ... },
    defaultProps: { ... },
    deprecatedProps: { ... },
    ...
  };
}

declare module "@deck.gl/core/lifecycle/create-props" {
  declare export function createProps(): any;
}

declare module "@deck.gl/core/lifecycle/component-state" {
  declare export default class ComponentState {
    constructor(component?: any): this;
    getOldProps(): any;
    resetOldProps(): void;
    freezeAsyncOldProps(): void;
    hasAsyncProp(propName: any): boolean;
    getAsyncProp(propName: any): any;
    isAsyncPropLoading(propName: any): boolean;
    setAsyncProps(props: any): void;
    _updateAsyncProp(propName: any, value: any): void;
    _didAsyncInputValueChange(propName: any, value: any): boolean;
    _setPropValue(propName: any, value: any): void;
    _setAsyncPropValue(propName: any, value: any, loadCount: any): void;
    _watchPromise(propName: any, promise: any): void;
    _resolveAsyncIterable(propName: any, iterable: any): Promise<void>;
    _postProcessValue(propName: any, value: any, previousValue: any): any;
    _createAsyncPropData(propName: any, value: any, defaultValue: any): void;
  }
}

declare module "@deck.gl/core/lifecycle/component" {
  import type { LayerContext } from "@deck.gl/core/lib/layer";

  declare export default class Component<P> {
    constructor(props: P): this;
    clone(newProps: P): any;
    stats: any;
    _initState(): void;
    props: P;

    /**
     * The layer's id, used for matching with layers from last render cycle
     */
    id: string;

    /**
     * Keep track of how many layer instances you are generating
     */
    count: number;

    /**
     * Helps track and debug the life cycle of the layers
     */
    lifecycle: string;

    /**
     * reference to the composite layer parent that rendered this layer
     */
    parent: Component<P>;

    /**
     * Will reference layer manager's context, contains state shared by layers
     */
    context: LayerContext;

    /**
     * Will be set to the shared layer state object during layer matching
     */
    state: any;
    internalState: any;
  }
}

declare module "@deck.gl/core/lib/layer-state" {
  import typeof ComponentState from "@deck.gl/core/lifecycle/component-state";

  declare export default class LayerState mixins ComponentState {
    constructor(x: {
      attributeManager: any,
      layer: any,
      ...
    }): this;
    layer: any;
    -layer: any;
  }
}

declare module "@deck.gl/core/lib/layer" {
  import typeof AttributeManager from "@deck.gl/core/lib/attribute/attribute-manager";

  import typeof Component from "@deck.gl/core/lifecycle/component";

  import type Deck, { PickInfo } from "@deck.gl/core/lib/deck";

  import typeof * as hammerjs from "hammerjs";

  import type { RGBAColor } from "@deck.gl/core/utils/color";

  import typeof LayerManager from "@deck.gl/core/lib/layer-manager";

  import typeof Viewport from "@deck.gl/core/viewports/viewport";

  declare export type LayerContext = {
    layerManager: LayerManager;
    deck: Deck;
    viewport: Viewport;
    mousePosition: [number, number] | null;
    gl: WebGL2RenderingContext;
  }
  declare export type BaseTransitionTiming = {
    enter?: (v: number) => number;
    onStart?: () => void;
    onEnd?: () => void;
    onInterrupt?: () => void;
  }
  declare export type InterpolationTransitionTiming = {
    type: "interpolation",
    duration: number,
    easing?: (t: number) => number,
    ...
  } & BaseTransitionTiming;

  declare export type SpringTransitionTiming = {
    type: "spring",
    stiffness: number,
    damping: number,
    ...
  } & BaseTransitionTiming;

  declare export type TransitionTiming =
    | InterpolationTransitionTiming
    | SpringTransitionTiming;
  declare export type LayerInputHandler<D = any> = {
    (o: PickInfo<D>, e: HammerInput): any;
  }
  declare export type DataSet<D> = Iterable<D>;
  declare export type LayerProps<D> = {
    id?: string;
    data?: DataSet<D> | Promise<DataSet<D>> | string;
    visible?: boolean;
    opacity?: number;
    extensions?: any[];
    pickable?: boolean;
    onHover?: LayerInputHandler<D>;
    onClick?: LayerInputHandler<D>;
    onDragStart?: LayerInputHandler<D>;
    onDrag?: LayerInputHandler<D>;
    onDragEnd?: LayerInputHandler<D>;
    highlightColor?: RGBAColor | ((pickInfo: PickInfo<D>) => RGBAColor);
    highlightedObjectIndex?: number;
    autoHighlight?: boolean;
    coordinateSystem?: number;
    coordinateOrigin?: [number, number];
    wrapLongitude?: boolean;
    modelMatrix?: number;
    dataComparator?: (newData: D, oldData: D) => boolean;
    dataTransform?: () => D[] | Iterable<D>;
    _dataDiff?: (
      newData: D,
      oldData: D
    ) => {
      startRow: number,
      endRow: number,
      ...
    };
    positionFormat?: "XYZ" | "XY";
    colorFormat?: "RGBA" | "RGB";
    numInstances?: number;
    updateTriggers?: any;
    onDataLoad?: (
      value: D[] | Iterable<D>,
      context: {
        layer: Layer<D>,
        ...
      }
    ) => void;
    parameters?: () => any;
    getPolygonOffset?: (uniform: any) => [number, number];
    transitions?: {
      [attributeGetter: string]: TransitionTiming,
      ...
    };
  }
  declare export type DefaultPropType = {
    name: string;
    value: any;
    async?: boolean;
    validate?: (value: any) => boolean;
    equal?: (value1: any, value2: any) => boolean;
    deprecatedFor?: string | string[];
  }
  declare export default class Layer<D, P: LayerProps<D> = LayerProps<D>>
    mixins Component<P> {
    constructor(props: P): this;
    toString(): string;
    setState(updateObject: any): void;
    setNeedsRedraw(redraw?: boolean): void;
    setNeedsUpdate(): void;
    getNeedsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): boolean;
    needsUpdate(): any;
    hasUniformTransition(): any;
    isLoaded: boolean;
    isPickable(): any;
    getModels(): any;
    getAttributeManager(): any;
    getCurrentLayer(): any;
    getLoadOptions(): any;
    project(xyz: any): any[];
    unproject(xy: any): any;
    projectPosition(xyz: any): any;
    use64bitPositions(): boolean;
    onHover(info: any, pickingEvent: any): any;
    onClick(info: any, pickingEvent: any): any;
    nullPickingColor(): RGBAColor;
    encodePickingColor(i: any, target?: any[]): RGBAColor;
    decodePickingColor(color: any): number;
    initializeState(params: any): void;
    getShaders(shaders: any): any;
    shouldUpdateState(x: {
      oldProps: any,
      props: any,
      context: any,
      changeFlags: any,
      ...
    }): any;
    updateState(x: {
      oldProps: any,
      props: any,
      context: any,
      changeFlags: any,
      ...
    }): void;
    finalizeState(): void;
    draw(opts: any): void;
    getPickingInfo(x: {
      info: any,
      mode: any,
      ...
    }): any;
    invalidateAttribute(name?: string, diffReason?: string): void;
    updateAttributes(changedAttributes: any): void;
    _updateAttributes(props: any): void;
    _updateAttributeTransition(): void;
    _updateUniformTransition(): any;
    calculateInstancePickingColors(
      attribute: any,
      x: {
        numInstances: any,
        ...
      }
    ): void;
    _setModelAttributes(model: any, changedAttributes: any): void;
    clearPickingColor(color: any): void;
    restorePickingColors(): void;
    getNumInstances(props: any): any;
    getStartIndices(props: any): any;
    _initialize(): void;
    _update(): void;
    _updateState(): void;
    _finalize(): void;
    drawLayer(x: {
      moduleParameters?: any,
      uniforms?: { ... },
      parameters?: { ... },
      ...
    }): void;
    getChangeFlags(): any;
    setChangeFlags(flags: any): void;
    clearChangeFlags(): void;
    diffProps(newProps: any, oldProps: any): void;
    validateProps(): void;
    setModuleParameters(moduleParameters: any): void;
    _updateModules(x: {
      props: any,
      oldProps: any,
      ...
    }): void;
    _getUpdateParams(): {
      props: any,
      oldProps: any,
      context: any,
      changeFlags: any,
      ...
    };
    _getNeedsRedraw(opts: any): boolean;
    _getAttributeManager(): AttributeManager;
    _initState(): void;
    _transferState(oldLayer: any): void;
    _onAsyncPropUpdated(): void;
    static layerName: string;
    static defaultProps?: {
      [key: string]: DefaultPropType | { [key: string]: any, ... } | any,
      ...
    };
  }
}

declare module "@deck.gl/core/lib/composite-layer" {
  import type Layer, { LayerProps } from "@deck.gl/core/lib/layer";

  declare export type CompositeLayerProps<D> = {
    _subLayerProps?: Object,
    ...
  } & LayerProps<D>;

  declare export default class CompositeLayer<
      D,
      P: CompositeLayerProps<D> = CompositeLayerProps<D>
    >
    mixins Layer<D, P> {
    isComposite: boolean;
    isLoaded: any;
    getSubLayers(): any;
    initializeState(params?: any): void;
    setState(updateObject: any): void;
    getPickingInfo(x: {
      info: any,
      ...
    }): any;
    renderLayers(): any;
    shouldRenderSubLayer(id: any, data: any): any;
    getSubLayerClass(id: any, DefaultLayerClass: any): any;
    getSubLayerRow(row: any, sourceObject: any, sourceObjectIndex: any): any;
    getSubLayerAccessor(accessor: any): any;
    getSubLayerProps<SD, SP: LayerProps<SD>>(sublayerProps?: { ... }): SP;
    _getAttributeManager(): any;
    _renderLayers(): void;
  }
}

declare module "@deck.gl/core/viewports/viewport" {
  import type { Position } from "@deck.gl/core/utils/positions";

  declare export default class Viewport {
    /**
 * @classdesc Manages coordinate system transformations for deck.gl.

Note: The Viewport is immutable in the sense that it only has accessors.
A new viewport instance should be created if any parameters have changed.
 */
    constructor(opts?: { ... }): this;
    id?: string;
    x: number;
    y: number;
    width: number;
    height: number;
    isGeospatial: boolean;
    zoom: number;
    scale: number;
    position: Position;
    metersPerPixel: number;
    projectionMode: number;
    equals(viewport: any): any;

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {object} opts - options
     * @param {Object} opts.topLeft =true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */
    project(
      xyz: any,
      x?: {
        topLeft?: boolean,
        ...
      }
    ): any[];

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {object} opts - options
     * @param {Object} opts.topLeft =true - Whether origin is top left
     * @return {Array | null} - [lng, lat, Z] or [X, Y, Z]
     */
    unproject(
      xyz: any,
      x?: {
        topLeft?: boolean,
        targetZ: any,
        ...
      }
    ): any[];
    projectPosition(xyz: any): any[];
    unprojectPosition(xyz: any): any[];

    /**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 * @param {Array} lngLat - [lng, lat] coordinates
Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
    projectFlat(xyz: any): any;

    /**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 * @param {{[key: string]: any} | Vector} xy - object with {x,y} members
representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
Has toArray method if you need a GeoJSON Array.
Per cartographic tradition, lat and lon are specified as degrees.
 */
    unprojectFlat(xyz: any): any;
    getDistanceScales(coordinateOrigin?: any): any;
    containsPixel(x: {
      x: any,
      y: any,
      width?: number,
      height?: number,
      ...
    }): boolean;
    getFrustumPlanes(): any;
    getCameraPosition(): any;
    getCameraDirection(): any;
    getCameraUp(): any;
    _createProjectionMatrix(x: {
      orthographic: any,
      fovyRadians: any,
      aspect: any,
      focalDistance: any,
      near: any,
      far: any,
      ...
    }): any;
    _initViewMatrix(opts: any): void;
    _getCenterInWorld(x: {
      longitude: any,
      latitude: any,
      ...
    }): any;
    _initProjectionMatrix(opts: any): void;
    _initPixelMatrices(): void;
  }
}

declare module "@deck.gl/core/lib/layer-manager" {
  declare export default class LayerManager {
    constructor(
      gl: any,
      x?: {
        deck: any,
        stats: any,
        viewport?: any,
        timeline?: any,
        ...
      }
    ): this;
    finalize(): void;
    needsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): any;
    needsUpdate(): any;
    setNeedsRedraw(reason: any): void;
    setNeedsUpdate(reason: any): void;
    getLayers(x?: {
      layerIds?: any,
      ...
    }): any;
    setProps(props: any): void;
    setLayers(newLayers: any, forceUpdate?: boolean): this;
    updateLayers(): void;
    activateViewport(viewport: any): this;
    _handleError(stage: any, error: any, layer: any): void;
    _updateLayers(oldLayers: any, newLayers: any): void;
    _updateSublayersRecursively(
      newLayers: any,
      oldLayerMap: any,
      generatedLayers: any
    ): void;
    _finalizeOldLayers(oldLayerMap: any): void;
    _initializeLayer(layer: any): void;
    _transferLayerState(oldLayer: any, newLayer: any): void;
    _updateLayer(layer: any): void;
    _finalizeLayer(layer: any): void;
  }
}

declare module "@deck.gl/core/utils/deep-equal" {
  declare export function deepEqual(a: any, b: any): boolean;
}

declare module "@deck.gl/core/lib/view-manager" {
  declare export default class ViewManager {
    constructor(props?: { ... }): this;
    finalize(): void;
    needsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): any;
    setNeedsUpdate(reason: any): void;
    updateViewStates(): void;

    /**
 * Get a set of viewports for a given width and height
 * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
 * @param rect (object, optional) - filter the viewports
+ not provided - return all viewports
+ {x, y} - only return viewports that contain this pixel
+ {x, y, width, height} - only return viewports that overlap with this rectangle
 */
    getViewports(rect: any): any;
    getViews(): { ... };
    getView(viewOrViewId: any): any;
    getViewState(viewId: any): any;
    getViewport(viewId: any): any;

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @param {object} opts - options
     * @param {Object} opts.topLeft =true - Whether origin is top left
     * @return {Array | null} - [lng, lat, Z] or [X, Y, Z]
     */
    unproject(xyz: any, opts: any): any;
    setProps(props: any): void;
    _update(): void;
    _setSize(width: any, height: any): void;
    _setViews(views: any): void;
    _setViewState(viewState: any): void;
    _onViewStateChange(viewId: any, event: any): void;
    _createController(props: any): any;
    _updateController(
      view: any,
      viewState: any,
      viewport: any,
      controller: any
    ): any;
    _rebuildViewports(): void;
    _buildViewportMap(): void;
    _diffViews(newViews: any, oldViews: any): any;
  }
}

declare module "@deck.gl/core/utils/positions" {
  declare export type Position2D = [number, number];
  declare export type Position3D = [number, number, number];
  declare export type Position = Position2D | Position3D;
  declare export function parsePosition(
    value: any
  ): {
    position: number,
    relative: boolean,
    ...
  };

  declare export function getPosition(position: any, extent: any): any;
}

declare module "@deck.gl/core/views/view" {
  declare export default class View {
    constructor(props?: { ... }): this;
    equals(view: any): any;
    makeViewport(x: {
      width: any,
      height: any,
      viewState: any,
      ...
    }): any;
    getViewStateId(): any;
    filterViewState(viewState: any): any;
    getDimensions(x: {
      width: any,
      height: any,
      ...
    }): {
      x: any,
      y: any,
      width: any,
      height: any,
      ...
    };
    _getControllerProps(defaultOpts: any): any;
    _getViewport(props: any): any;
    _parseDimensions(x: {
      x: any,
      y: any,
      width: any,
      height: any,
      ...
    }): void;
  }
}

declare module "@deck.gl/core/viewports/web-mercator-viewport" {
  import typeof Viewport from "@deck.gl/core/viewports/viewport";

  declare export default class WebMercatorViewport mixins Viewport {
    /**
 * @classdesc Creates view/projection matrices from mercator params
Note: The Viewport is immutable in the sense that it only has accessors.
A new viewport instance should be created if any parameters have changed.
 */
    constructor(opts?: { ... }): this;
    subViewports: any;

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     * @param {[Number, Number] | [Number, Number, Number]}  ) lngLatZ - base coordinate
     * @param {[Number, Number] | [Number, Number, Number]}  ) xyz - array of meter deltas
     * @return {[Number, Number] | [Number, Number, Number]} ) array of [lng,lat,z] deltas
     */
    addMetersToLngLat(lngLatZ: any, xyz: any): any;

    /**
 * Get the map center that place a given [lng, lat] coordinate at screen
 * point [x, y]
 * @param {Array} lngLat - [lng,lat] coordinates
Specifies a point on the sphere.
 * @param {Array} pos - [x,y] coordinates
Specifies a point on the screen.
 * @return {Array} [lng,lat] new map center.
 */
    getMapCenterByLngLatPosition(x: {
      lngLat: any,
      pos: any,
      ...
    }): any;

    /**
 * Returns a new viewport that fit around the given rectangle.
 * Only supports non-perspective mode.
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
[x, y] measured in pixels.
 * @returns {WebMercatorViewport}
 */
    fitBounds(bounds: any, options?: { ... }): WebMercatorViewport;
  }
}

declare module "@deck.gl/core/transitions/transition-interpolator" {
  declare export default class TransitionInterpolator {
    /**
 * @param {array | {[key: string]: any}} opts
 * @param {array} opts.compare - prop names used in equality check
 * @param {array} opts.extract - prop names needed for interpolation
 * @param {array} opts.required - prop names that must be supplied
alternatively, supply one list of prop names as `opts` if all of the above are the same.
 */
    constructor(opts?: { ... }): this;

    /**
     * Checks if two sets of props need transition in between
     * @param {{[key: string]: any}} currentProps - a list of viewport props
     * @param {{[key: string]: any}} nextProps - a list of viewport props
     * @returns {bool} - true if two props are equivalent
     */
    arePropsEqual(currentProps: any, nextProps: any): boolean;

    /**
 * Called before transition starts to validate/pre-process start and end props
 * @param {{[key: string]: any}} startProps - a list of starting viewport props
 * @param {{[key: string]: any}} endProps - a list of target viewport props
 * @returns {Object} {start, end} - start and end props to be passed
to `interpolateProps`
 */
    initializeProps(startProps: any, endProps: any): any;

    /**
     * Returns viewport props in transition
     * @param {{[key: string]: any}} startProps - a list of starting viewport props
     * @param {{[key: string]: any}} endProps - a list of target viewport props
     * @param {number} t - a time factor between [0, 1]
     * @returns {{[key: string]: any}} - a list of interpolated viewport props
     */
    interpolateProps(startProps: any, endProps: any, t: any): any;

    /**
     * Returns transition duration
     * @param {{[key: string]: any}} startProps - a list of starting viewport props
     * @param {{[key: string]: any}} endProps - a list of target viewport props
     * @returns {Number} - transition duration in milliseconds
     */
    getDuration(startProps: any, endProps: any): any;
    _checkRequiredProps(props: any): void;
  }
}

declare module "@deck.gl/core/transitions/linear-interpolator" {
  import typeof TransitionInterpolator from "@deck.gl/core/transitions/transition-interpolator";

  /**
   * Performs linear interpolation of two view states.
   */
  declare export default class LinearInterpolator
    mixins TransitionInterpolator {
    /**
     * @param {Array} transitionProps - list of props to apply linear transition to.
     */
    constructor(transitionProps?: string[]): this;
    interpolateProps(startProps: any, endProps: any, t: any): { ... };
  }
}

declare module "@deck.gl/core/controllers/transition-manager" {
  declare export var TRANSITION_EVENTS: {
    BREAK: number,
    SNAP_TO_END: number,
    IGNORE: number,
    ...
  };
  declare export default class TransitionManager {
    constructor(ControllerState: any, props?: { ... }): this;
    finalize(): void;
    getViewportInTransition(): any;
    processViewStateChange(nextProps: any): boolean;
    updateTransition(): void;
    _isTransitionEnabled(props: any): boolean;
    _isUpdateDueToCurrentTransition(props: any): any;
    _shouldIgnoreViewportChange(currentProps: any, nextProps: any): any;
    _triggerTransition(startProps: any, endProps: any): void;
    _onTransitionEnd(callback: any): (transition: any) => void;
    _onTransitionUpdate(transition: any): void;
  }
}

declare module "@deck.gl/core/controllers/controller" {
  declare export type ControllerOptions = {
    scrollZoom?: boolean;
    dragPan?: boolean;
    dragRotate?: boolean;
    doubleClickZoom?: boolean;
    touchZoom?: boolean;
    touchRotate?: boolean;
    keyboard?: boolean;
  }
  declare export default class Controller {
    constructor(ControllerState: any, options?: ControllerOptions): this;
    -events: any;
    finalize(): void;

    /**
     * Callback for events
     * @param {hammer.Event} event
     */
    handleEvent(event: any): boolean;
    getCenter(event: any): number[];
    isPointInBounds(pos: any, event: any): boolean;
    isFunctionKeyPressed(event: any): boolean;
    isDragging(): any;

    /**
     * Extract interactivity options
     */
    setProps(props: any): void;
    updateTransition(): void;
    toggleEvents(eventNames: any, enabled: any): void;
    updateViewport(
      newControllerState: any,
      extraProps?: { ... },
      interactionState?: { ... }
    ): void;
    _onPanStart(event: any): boolean;
    _onPan(event: any): boolean;
    _onPanEnd(event: any): boolean;
    _onPanMove(event: any): boolean;
    _onPanRotate(event: any): boolean | void;
    _onWheel(event: any): boolean;
    _onPinchStart(event: any): boolean;
    _onPinch(event: any): boolean;
    _onPinchEnd(event: any): boolean;
    _onDoubleTap(event: any): boolean;
    _onKeyDown(event: any): boolean;
    _getTransitionProps(): {
      transitionDuration: number,
      ...
    };
  }
}

declare module "@deck.gl/core/controllers/view-state" {
  declare export default class ViewState {
    constructor(opts: any): this;
    getViewportProps(): any;
    shortestPathFrom(viewState: any): any;
    _applyConstraints(props: any): any;
  }
}

declare module "@deck.gl/core/controllers/map-controller" {
  import typeof Controller from "@deck.gl/core/controllers/controller";

  import typeof ViewState from "@deck.gl/core/controllers/view-state";

  import typeof LinearInterpolator from "@deck.gl/core/transitions/linear-interpolator";

  declare export var MAPBOX_LIMITS: {
    minZoom: number,
    maxZoom: number,
    minPitch: number,
    maxPitch: number,
    ...
  };
  declare class MapState mixins ViewState {
    constructor(x?: {
      width: any,
      height: any,
      latitude: any,
      longitude: any,
      zoom: any,
      bearing?: number,
      pitch?: number,
      altitude?: number,
      maxZoom?: number,
      minZoom?: number,
      maxPitch?: number,
      minPitch?: number,
      startPanLngLat: any,
      startZoomLngLat: any,
      startBearing: any,
      startPitch: any,
      startZoom: any,
      ...
    }): this;
    getViewportProps(): any;
    getInteractiveState(): any;

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    panStart(x: {
      pos: any,
      ...
    }): MapState;

    /**
 * Pan
 * @param {[Number, Number]} pos - position on screen where the pointer is
 * @param {[Number, Number]}  , optional} startPos - where the pointer grabbed at
the start of the operation. Must be supplied of `panStart()` was not called
 */
    pan(x: {
      pos: any,
      startPos: any,
      ...
    }): MapState;

    /**
     * End panning
     * Must call if `panStart()` was called
     */
    panEnd(): MapState;

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */
    rotateStart(x: {
      pos: any,
      ...
    }): MapState;

    /**
 * Rotate
 * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
change to bearing.
 * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
 */
    rotate(x: {
      deltaScaleX?: number,
      deltaScaleY?: number,
      ...
    }): MapState;

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */
    rotateEnd(): MapState;

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */
    zoomStart(x: {
      pos: any,
      ...
    }): MapState;

    /**
 * Zoom
 * @param {[Number, Number]} pos - position on screen where the current center is
 * @param {[Number, Number]} startPos - the center position at
the start of the operation. Must be supplied of `zoomStart()` was not called
 * @param {Number} scale - a number between [0, 1] specifying the accumulated
relative scale.
 */
    zoom(x: {
      pos: any,
      startPos: any,
      scale: any,
      ...
    }): MapState;

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */
    zoomEnd(): MapState;
    zoomIn(): any;
    zoomOut(): any;
    moveLeft(): MapState;
    moveRight(): MapState;
    moveUp(): MapState;
    moveDown(): MapState;
    rotateLeft(): MapState;
    rotateRight(): MapState;
    rotateUp(): MapState;
    rotateDown(): MapState;
    shortestPathFrom(viewState: any): any;
    _zoomFromCenter(scale: any): any;
    _panFromCenter(offset: any): MapState;
    _getUpdatedState(newProps: any): MapState;
    _applyConstraints(props: any): any;
    _unproject(pos: any): any;
    _calculateNewLngLat(x: {
      startPanLngLat: any,
      pos: any,
      ...
    }): any;
    _calculateNewZoom(x: {
      scale: any,
      startZoom: any,
      ...
    }): any;
    _calculateNewPitchAndBearing(x: {
      deltaScaleX: any,
      deltaScaleY: any,
      startBearing: any,
      startPitch: any,
      ...
    }): {
      pitch: any,
      bearing: any,
      ...
    };
  }
  declare export default class MapController mixins Controller {
    constructor(props: any): this;
    _getTransitionProps(): {
      transitionDuration: number,
      transitionEasing: (t: any) => any,
      transitionInterpolator: LinearInterpolator,
      transitionInterruption: number,
      ...
    };
    _onPanRotate(event: any): false | void;
  }
  declare export var testExports: {
    MapState: typeof MapState,
    ...
  };
  declare export {};
}

declare module "@deck.gl/core/views/map-view" {
  import typeof View from "@deck.gl/core/views/view";

  declare export default class MapView mixins View {
    constructor(props: any): this;
    controller: any;
  }
}

declare module "@deck.gl/core/lib/effect-manager" {
  declare export default class EffectManager {
    constructor(): this;
    setProps(props: any): void;
    needsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): any;
    getEffects(): any;
    finalize(): void;
    setEffects(effects?: any[]): void;
    cleanup(): void;
    _createInternalEffects(): void;
  }
}

declare module "@deck.gl/core/passes/draw-layers-pass" {
  import typeof LayersPass from "@deck.gl/core/passes/layers-pass";

  declare export default class DrawLayersPass mixins LayersPass {}
}

declare module "@deck.gl/core/passes/pick-layers-pass" {
  import typeof LayersPass from "@deck.gl/core/passes/layers-pass";

  declare export default class PickLayersPass mixins LayersPass {
    render(props: any): void;
    _drawPickingBuffer(x: {
      layers: any,
      layerFilter: any,
      viewports: any,
      onViewportActive: any,
      pickingFBO: any,
      deviceRect: {
        x: any,
        y: any,
        width: any,
        height: any,
        ...
      },
      pass?: string,
      redrawReason: any,
      pickZ: any,
      ...
    }): any;
    shouldDrawLayer(layer: any): any;
    getModuleParameters(): {
      pickingActive: number,
      pickingAttribute: any,
      lightSources: { ... },
      ...
    };
    getLayerParameters(layer: any, layerIndex: any): any;
  }
}

declare module "@deck.gl/core/lib/deck-renderer" {
  declare export default class DeckRenderer {
    constructor(gl: any): this;
    setProps(props: any): void;
    renderLayers(opts: any): void;
    needsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): any;
    finalize(): void;
    _preRender(effects: any, opts: any): void;
    _resizeRenderBuffers(): void;
    _postRender(effects: any, opts: any): void;
  }
}

declare module "@deck.gl/core/lib/picking/query-object" {
  /**
   * Pick at a specified pixel with a tolerance radius
   * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
   */
  declare export function getClosestObject(x: {
    pickedColors: any,
    layers: any,
    deviceX: any,
    deviceY: any,
    deviceRadius: any,
    deviceRect: any,
    ...
  }):
    | {
        pickedColor: any,
        pickedLayer: any,
        pickedObjectIndex: number,
        ...
      }
    | {
        pickedColor: any,
        pickedLayer: any,
        pickedObjectIndex: any,
        pickedX: any,
        pickedY: any,
        ...
      };

  /**
   * Examines a picking buffer for unique colors
   * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
   */
  declare export function getUniqueObjects(x: {
    pickedColors: any,
    layers: any,
    ...
  }): any[];
}

declare module "@deck.gl/core/lib/picking/pick-info" {
  declare export function processPickInfo(x: {
    pickInfo: any,
    lastPickedInfo: any,
    mode: any,
    layers: any,
    viewports: any,
    x: any,
    y: any,
    z: any,
    pixelRatio: any,
    ...
  }): Map<any, any>;

  declare export function getLayerPickingInfo(x: {
    layer: any,
    info: any,
    mode: any,
    ...
  }): any;
}

declare module "@deck.gl/core/lib/deck-picker" {
  declare export default class DeckPicker {
    constructor(gl: any): this;
    setProps(props: any): void;
    finalize(): void;
    pickObject(
      opts: any
    ): {
      result: any[],
      emptyInfo: any,
      ...
    };
    pickObjects(opts: {
      x: any,
      y: any,
      width: any,
      height: any,
      layers: any,
      viewports: any,
      activateViewport: any,
      ...
    }): any[];
    getLastPickedObject(
      x: {
        x: any,
        y: any,
        layers: any,
        viewports: any,
        ...
      },
      lastPickedInfo?: any
    ): any;
    _resizeBuffer(): any;
    _pickClosestObject(x: {
      layers: any,
      viewports: any,
      x: any,
      y: any,
      radius?: number,
      depth?: number,
      mode?: string,
      unproject3D: any,
      onViewportActive: any,
      ...
    }): {
      result: any[],
      emptyInfo: any,
      ...
    };
    _pickVisibleObjects(x: {
      layers: any,
      viewports: any,
      x: any,
      y: any,
      width?: number,
      height?: number,
      mode?: string,
      onViewportActive: any,
      ...
    }): any[];
    _drawAndSample(x: {
      layers: any,
      viewports: any,
      onViewportActive: any,
      deviceRect: any,
      pass: any,
      redrawReason: any,
      pickZ: any,
      ...
    }): Float32Array | Uint8Array;
    _getPickingRect(x: {
      deviceX: any,
      deviceY: any,
      deviceRadius: any,
      deviceWidth: any,
      deviceHeight: any,
      ...
    }): {
      x: number,
      y: number,
      width: number,
      height: number,
      ...
    };
  }
}

declare module "@deck.gl/core/lib/tooltip" {
  declare export default class Tooltip {
    constructor(canvas: any): this;
    setTooltip(displayInfo: any, x: any, y: any): void;
    remove(): void;
  }
}

declare module "@deck.gl/core/lib/deck" {
  import type Controller, {
    ControllerOptions,
  } from "@deck.gl/core/controllers/controller";

  import typeof Effect from "@deck.gl/core/lib/effect";

  import typeof Layer from "@deck.gl/core/lib/layer";

  import typeof View from "@deck.gl/core/views/view";

  import typeof Viewport from "@deck.gl/core/viewports/viewport";

  import typeof TransitionInterpolator from "@deck.gl/core/transitions/transition-interpolator";

  import typeof { TRANSITION_EVENTS } from "@deck.gl/core/controllers/transition-manager";

  declare export type InteractiveState = {
    isDragging: boolean;
  }
  declare export type PickInfo<D> = {
    layer: Layer<D>;
    index: number;
    object: D;
    x: number;
    y: number;
    coordinate?: { ... };
  }
  declare export type InitialViewStateProps = {
    latitude?: number;
    longitude?: number;
    zoom?: number;
    bearing?: number;
    pitch?: number;
    altitude?: number;
    maxPitch?: number;
    maxZoom?: number;
    minPitch?: number;
    minZoom?: number;
  }
  declare export type ViewStateProps = {
    transitionDuration?: number | string,
    transitionEasing?: (x: number) => number,
    transitionInterpolator?: TransitionInterpolator,
    transitionInterruption?: typeof TRANSITION_EVENTS,
    onTransitionStart?: () => void,
    onTransitionInterrupt?: () => void,
    onTransitionEnd?: () => void,
    ...
  } & InitialViewStateProps;

  declare export type DeckProps = {
    width: string | number;
    height: string | number;
    layers: Layer<any>[];
    layerFilter?: (args: {
      layer: Layer<any>,
      viewport: Viewport,
      isPicking: boolean,
      renderPass: string,
      ...
    }) => boolean;
    getCursor?: (interactiveState: InteractiveState) => string;
    views?: View[];
    viewState?: ViewStateProps;
    initialViewState?: InitialViewStateProps;
    controller?: null | Controller | ControllerOptions | boolean;
    effects: Effect[];
    id?: string;
    style?: { ... };
    canvas?: HTMLCanvasElement;
    touchAction?: string;
    pickingRadius?: number;
    getTooltip?: <D>(
      info: PickInfo<D>
    ) => null | {
      text?: string,
      html?: string,
      className?: string,
      style?: { ... },
      ...
    };
    useDevicePixels?: boolean | number;
    gl?: WebGLRenderingContext;
    glOptions?: WebGLContextAttributes;
    _framebuffer?: any;
    parameters?: { [key: string]: any };
    debug?: boolean;
    _animate?: boolean;
    onWebGLInitialized?: (gl: WebGLRenderingContext) => any;
    onViewStateChange?: (args: {
      viewState: any,
      interactionState: {
        inTransition?: boolean,
        isDragging?: boolean,
        isPanning?: boolean,
        isRotating?: boolean,
        isZooming?: boolean,
        ...
      },
      oldViewState: any,
      ...
    }) => any;
    onHover?: <D>(info: PickInfo<D>, e: MouseEvent) => any;
    onClick?: <D>(info: PickInfo<D>, e: MouseEvent) => any;
    onDragStart?: <D>(info: PickInfo<D>, e: MouseEvent) => any;
    onDrag?: <D>(info: PickInfo<D>, e: MouseEvent) => any;
    onDragEnd?: <D>(info: PickInfo<D>, e: MouseEvent) => any;
    onLoad?: () => void;
    onResize?: (size: {
      height: number,
      width: number,
      ...
    }) => void;
    onBeforeRender?: (args: {
      gl: WebGLRenderingContext,
      ...
    }) => void;
    onAfterRender?: (args: {
      gl: WebGLRenderingContext,
      ...
    }) => void;
    onError?: (error: Error, source: any) => void;
    _onMetrics?: (metrics: any) => void;
    ContextProvider?: React$Provider<any>;
  }
  declare export default class Deck {
    constructor(props: DeckProps): this;
    canvas: HTMLCanvasElement;
    viewState: any;
    finalize(): void;
    props: DeckProps;
    setProps(props: $Rest<DeckProps, { ... }>): void;
    needsRedraw(opts?: {
      clearRedrawFlags: boolean,
      ...
    }): any;
    redraw(force: any): void;
    getViews(): any;
    getViewports(rect: any): any;
    pickObject(x: {
      x: any,
      y: any,
      radius?: number,
      layerIds?: any,
      ...
    }): any;
    pickMultipleObjects(x: {
      x: any,
      y: any,
      radius?: number,
      layerIds?: any,
      depth?: number,
      ...
    }): any;
    pickObjects(x: {
      x: any,
      y: any,
      width?: number,
      height?: number,
      layerIds?: any,
      ...
    }): any;
    _pick(method: any, statKey: any, opts: any): any;
    _createCanvas(props: any): any;
    _setCanvasSize(props: any): void;
    _updateCanvasSize(): void;
    _checkForCanvasSizeChange(): boolean;
    _createAnimationLoop(props: any): any;
    _getViewState(): any;
    _getViews(): any;
    _onPointerMove(event: any): void;
    _pickAndCallback(): void;
    _updateCursor(): void;
    _setGLContext(gl: any): void;
    _drawLayers(redrawReason: any, renderOptions: any): void;
    _onRendererInitialized(x: {
      gl: any,
      ...
    }): void;
    _onRenderFrame(animationProps: any): void;
    _onViewStateChange(params: any): void;
    _onInteractiveStateChange(x: {
      isDragging?: boolean,
      ...
    }): void;
    _onEvent(event: any): void;
    _onPointerDown(event: any): void;
    _getFrameStats(): void;
    _getMetrics(): void;
  }
}

declare module "@deck.gl/core/lib/layer-extension" {
  declare export default class LayerExtension {
    constructor(opts?: { ... }): this;
    equals(extension: any): boolean;
    getShaders(extension: any): any;
    getSubLayerProps(
      extension: any
    ): {
      updateTriggers: { ... },
      ...
    };
    initializeState(context: any, extension: any): void;
    updateState(params: any, extension: any): void;
    draw(params: any, extension: any): void;
    finalizeState(extension: any): void;
  }
}

declare module "@deck.gl/core/effects/lighting/point-light" {
  declare export class PointLight {
    constructor(props?: { ... }): this;
    getProjectedLight(x: {
      layer: any,
      ...
    }): any;
  }
}

declare module "@deck.gl/core/effects/lighting/camera-light" {
  import type { PointLight } from "@deck.gl/core/effects/lighting/point-light";

  declare export default class CameraLight mixins PointLight {
    getProjectedLight(x: {
      layer: any,
      ...
    }): any;
  }
}

declare module "@deck.gl/core/effects/lighting/suncalc" {
  declare export function getSolarPosition(
    timestamp: any,
    latitude: any,
    longitude: any
  ): {
    azimuth: number,
    altitude: number,
    ...
  };

  declare export function getSunlightDirection(
    timestamp: any,
    latitude: any,
    longitude: any
  ): number[];
}

declare module "@deck.gl/core/effects/lighting/sun-light" {
  import type { DirectionalLight } from "@deck.gl/core/effects/lighting/directional-light";

  declare export default class SunLight mixins DirectionalLight {
    constructor(x: {
      [x: string]: any,
      timestamp: any,
      ...
    }): this;
    getProjectedLight(x: {
      layer: any,
      ...
    }): this;
  }
}

declare module "@deck.gl/core/passes/screen-pass" {
  import typeof Pass from "@deck.gl/core/passes/pass";

  declare export default class ScreenPass mixins Pass {
    constructor(gl: any, props?: { ... }): this;
    render(params: any): void;
    delete(): void;

    /**
     * Renders the pass.
     * This is an abstract method that should be overridden.
     * @param {Framebuffer} inputBuffer - Frame buffer that contains the result of the previous pass
     * @param {Framebuffer} outputBuffer - Frame buffer that serves as the output render target
     */
    _renderPass(
      gl: any,
      x: {
        inputBuffer: any,
        outputBuffer: any,
        ...
      }
    ): void;
  }
}

declare module "@deck.gl/core/effects/post-process-effect" {
  import typeof Effect from "@deck.gl/core/lib/effect";

  declare export default class PostProcessEffect mixins Effect {
    constructor(module: any, props?: { ... }): this;
    postRender(gl: any, params: any): any;
    cleanup(): void;
  }
}

declare module "@deck.gl/core/controllers/first-person-controller" {
  import typeof Controller from "@deck.gl/core/controllers/controller";

  declare export default class FirstPersonController mixins Controller {
    constructor(props: any): this;
  }
}

declare module "@deck.gl/core/views/first-person-view" {
  import typeof View from "@deck.gl/core/views/view";

  import typeof Viewport from "@deck.gl/core/viewports/viewport";

  declare export default class FirstPersonView mixins View {
    controller: any;
    _getViewport(props: any): Viewport;
  }
}

declare module "@deck.gl/core/controllers/orbit-controller" {
  import typeof Controller from "@deck.gl/core/controllers/controller";

  import typeof ViewState from "@deck.gl/core/controllers/view-state";

  import typeof LinearInterpolator from "@deck.gl/core/transitions/linear-interpolator";

  declare export class OrbitState mixins ViewState {
    constructor(x: {
      ViewportType: any,
      width: any,
      height: any,
      orbitAxis?: string,
      rotationX?: number,
      rotationOrbit?: number,
      target?: number[],
      zoom?: number,
      minRotationX?: number,
      maxRotationX?: number,
      minZoom?: number,
      maxZoom?: number,
      startPanPosition: any,
      startTarget: any,
      startRotationX: any,
      startRotationOrbit: any,
      startZoomPosition: any,
      startZoom: any,
      ...
    }): this;
    getViewportProps(): any;
    getInteractiveState(): any;

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    panStart(x: {
      pos: any,
      ...
    }): OrbitState;

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */
    pan(x: {
      pos: any,
      startPos: any,
      ...
    }): OrbitState;

    /**
     * End panning
     * Must call if `panStart()` was called
     */
    panEnd(): OrbitState;

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    rotateStart(x: {
      pos: any,
      ...
    }): OrbitState;

    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */
    rotate(x: {
      deltaScaleX: any,
      deltaScaleY: any,
      ...
    }): OrbitState;

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */
    rotateEnd(): OrbitState;
    shortestPathFrom(viewState: any): any;

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */
    zoomStart(x: {
      pos: any,
      ...
    }): OrbitState;

    /**
 * Zoom
 * @param {[Number, Number]} pos - position on screen where the current target is
 * @param {[Number, Number]} startPos - the target position at
the start of the operation. Must be supplied of `zoomStart()` was not called
 * @param {Number} scale - a number between [0, 1] specifying the accumulated
relative scale.
 */
    zoom(x: {
      pos: any,
      startPos: any,
      scale: any,
      ...
    }): OrbitState;

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */
    zoomEnd(): OrbitState;
    zoomIn(): OrbitState;
    zoomOut(): OrbitState;
    moveLeft(): OrbitState;
    moveRight(): OrbitState;
    moveUp(): OrbitState;
    moveDown(): OrbitState;
    rotateLeft(): OrbitState;
    rotateRight(): OrbitState;
    rotateUp(): OrbitState;
    rotateDown(): OrbitState;
    _calculateNewZoom(x: {
      scale: any,
      startZoom: any,
      ...
    }): any;
    _calculateNewTarget(x: {
      startTarget: any,
      zoom: any,
      pixelOffset: any,
      ...
    }): any;
    _getUpdatedState(newProps: any): OrbitState;
    _applyConstraints(props: any): any;
  }
  declare export default class OrbitController mixins Controller {
    constructor(props: any): this;
    _getTransitionProps(): {
      transitionDuration: number,
      transitionEasing: (t: any) => any,
      transitionInterpolator: LinearInterpolator,
      transitionInterruption: number,
      ...
    };
  }
}

declare module "@deck.gl/core/views/orbit-view" {
  import typeof View from "@deck.gl/core/views/view";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type OrbitViewState = {
    target: Position;
    rotationOrbit?: number;
    rotationX?: number;
    zoom?: number;
    minZoom?: number;
    maxZoom?: number;
    minRotationX?: number;
    maxRotationX?: number;
  }
  declare export default class OrbitView mixins View {
    constructor(props: any): this;
    controller: any;
  }
}

declare module "@deck.gl/core/controllers/orthographic-controller" {
  import typeof Controller from "@deck.gl/core/controllers/controller";

  import typeof LinearInterpolator from "@deck.gl/core/transitions/linear-interpolator";

  declare export default class OrthographicController mixins Controller {
    constructor(props: any): this;
    _onPanRotate(event: any): boolean | void;
    _getTransitionProps(): {
      transitionDuration: number,
      transitionEasing: (t: any) => any,
      transitionInterpolator: LinearInterpolator,
      transitionInterruption: number,
      ...
    };
  }
}

declare module "@deck.gl/core/views/orthographic-view" {
  import typeof View from "@deck.gl/core/views/view";

  declare export default class OrthographicView mixins View {
    constructor(props: any): this;
    controller: any;
  }
}

declare module "@deck.gl/core/transitions/viewport-fly-to-interpolator" {
  import typeof TransitionInterpolator from "@deck.gl/core/transitions/transition-interpolator";

  /**
   * This class adapts mapbox-gl-js Map#flyTo animation so it can be used in
   * react/redux architecture.
   * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.
   * It implements Smooth and efficient zooming and panning. algorithm by
   * "Jarke J. van Wijk and Wim A.A. Nuij"
   */
  declare export default class FlyToInterpolator mixins TransitionInterpolator {
    /**
 * @param {Object} props - `props.curve` (Number, optional, default: 1.414) - The zooming "curve" that will occur along the flight path.
- `props.speed` (Number, optional, default: 1.2) - The average speed of the animation defined in relation to `options.curve`, it linearly affects the duration, higher speed returns smaller durations and vice versa.
- `props.screenSpeed` (Number, optional) - The average speed of the animation measured in screenfuls per second. Similar to `opts.speed` it linearly affects the duration,  when specified `opts.speed` is ignored.
- `props.maxDuration` (Number, optional) - Maximum duration in milliseconds, if calculated duration exceeds this value, `0` is returned.
 */
    constructor(props?: { ... }): this;
    interpolateProps(startProps: any, endProps: any, t: any): any;
    getDuration(startProps: any, endProps: any): any;
  }
}

declare module "@deck.gl/core/utils/tesselator" {
  declare export default class Tesselator {
    constructor(opts?: { ... }): this;
    updateGeometry(opts: any): void;
    updatePartialGeometry(x: {
      startRow: any,
      endRow: any,
      ...
    }): void;
    updateGeometryAttributes(geometry: any, startIndex: any, size: any): void;
    getGeometrySize(geometry: any): void;
    getGeometryFromBuffer(geometryBuffer: any): any;
    _allocate(instanceCount: any, copy: any): void;

    /**
     * Visit all objects
     * `data` is expected to be an iterable consistent with the base Layer expectation
     */
    _forEachGeometry(visitor: any, startRow: any, endRow: any): void;
    _rebuildGeometry(dataRange: any): void;
  }
}

declare module "@deck.gl/core/utils/color" {
  declare export type RGBAColor = [number, number, number, number | void];
  declare export type ColorDomain = [number, number];
  declare export type ColorRange = [
    RGBAColor,
    RGBAColor,
    RGBAColor,
    RGBAColor,
    RGBAColor,
    RGBAColor
  ];
  declare function parseColor(color: any, target: any, index?: number): any;

  declare function applyOpacity(color: any, opacity?: number): any[];

  declare var _default: {
    parseColor: typeof parseColor,
    applyOpacity: typeof applyOpacity,
    ...
  };
  declare export default typeof _default;
}
