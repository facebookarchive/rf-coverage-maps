/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 * @flow
 */

declare module "@luma.gl/webgl/init" {
  declare class StatsManager {
    constructor(): this;
    get(name: any): any;
  }
  declare var lumaStats: StatsManager;
  declare export { lumaStats };

  declare var _default: any;
  declare export default typeof _default;
}

declare module "@luma.gl/webgl/webgl-utils/request-animation-frame" {
  declare export function requestAnimationFrame(
    callback: any
  ): number | NodeJS$Timeout;

  declare export function cancelAnimationFrame(timerId: any): void;
}

declare module "@luma.gl/webgl/utils/assert" {
  declare export default function assert(condition: any, message: any): void;
}

declare module "@luma.gl/webgl/utils/is-old-ie" {
  declare export default function isOldIE(opts?: { ... }): boolean;
}

declare module "@luma.gl/webgl/utils/utils" {
  /**
   * Returns a UID.
   * @param {String} id = - Identifier base name
   * @return {number} uid
   */
  declare export function uid(id?: string): string;

  /**
   * Verifies if a given number is power of two or not.
   * @param {{[key: string]: any}} n - The number to check.
   * @return {Array} Returns true if the given number is power of 2, false otherwise.
   */
  declare export function isPowerOfTwo(n: any): boolean;

  declare export function isObjectEmpty(obj: any): boolean;
}

declare module "@luma.gl/webgl/utils/format-value" {
  declare export function formatValue(v: any, opts?: { ... }): any;
}

declare module "@luma.gl/webgl/utils/stub-methods" {
  declare export function stubRemovedMethods(
    instance: any,
    className: any,
    version: any,
    methodNames: any
  ): void;
}

declare module "@luma.gl/webgl/utils/check-props" {
  declare export function checkProps(
    className: any,
    props: any,
    propChecks: any
  ): any;
}

declare module "utils" {
  declare export { default as isOldIE } from "@luma.gl/webgl/utils/is-old-ie";

  declare export { uid, isPowerOfTwo } from "@luma.gl/webgl/utils/utils";

  declare export { formatValue } from "@luma.gl/webgl/utils/format-value";

  declare export { stubRemovedMethods } from "@luma.gl/webgl/utils/stub-methods";

  declare export { checkProps } from "@luma.gl/webgl/utils/check-props";
}

declare module "@luma.gl/webgl/webgl-utils/webgl-checks" {
  declare export var ERR_CONTEXT: any; // "Invalid WebGLRenderingContext"
  declare export var ERR_WEBGL: any; // "Invalid WebGLRenderingContext"
  declare export var ERR_WEBGL2: any; // "Requires WebGL2"
  declare export function assertWebGLContext(gl: any): void;

  declare export function assertWebGL2Context(gl: any): void;
}

declare module "@luma.gl/webgl/webgl-utils/typed-array-utils" {
  declare export function getGLTypeFromTypedArray(arrayOrType: any): any;

  declare export function getTypedArrayFromGLType(
    glType: any,
    x?: {
      clamped?: boolean,
      ...
    }
  ):
    | Float32ArrayConstructor
    | Uint16ArrayConstructor
    | Uint32ArrayConstructor
    | Uint8ArrayConstructor
    | Uint8ClampedArrayConstructor
    | Int8ArrayConstructor
    | Int16ArrayConstructor
    | Int32ArrayConstructor;

  declare export function flipRows(x: {
    data: any,
    width: any,
    height: any,
    bytesPerPixel?: number,
    temp: any,
    ...
  }): void;

  declare export function scalePixels(x: {
    data: any,
    width: any,
    height: any,
    ...
  }): {
    data: Uint8Array,
    width: number,
    height: number,
    ...
  };
}

declare module "@luma.gl/webgl/webgl-utils/constants-to-keys" {
  declare export function getKeyValue(gl: any, name: any): any;

  declare export function getKey(gl: any, value: any): string;

  declare export function getKeyType(gl: any, value: any): string;
}

declare module "webgl-utils" {
  declare export {
    assertWebGLContext,
    assertWebGL2Context,
  } from "@luma.gl/webgl/webgl-utils/webgl-checks";

  declare export {
    requestAnimationFrame,
    cancelAnimationFrame,
  } from "@luma.gl/webgl/webgl-utils/request-animation-frame";

  declare export {
    getGLTypeFromTypedArray,
    getTypedArrayFromGLType,
    flipRows,
    scalePixels,
  } from "@luma.gl/webgl/webgl-utils/typed-array-utils";

  declare export {
    getKeyValue,
    getKey,
    getKeyType,
  } from "@luma.gl/webgl/webgl-utils/constants-to-keys";

  declare export { cloneTextureFrom } from "@luma.gl/webgl/webgl-utils/texture-utils";
}

declare module "@luma.gl/webgl/classes/resource" {
  declare export default class Resource {
    constructor(gl: any, opts?: { ... }): this;
    toString(): string;
    handle: any;
    delete(x?: {
      deleteChildren?: boolean,
      ...
    }): this | void;
    bind(funcOrHandle?: any): any;
    unbind(): void;

    /**
     * Query a Resource parameter
     * @param {GLenum} pname
     * @return {GLint | GLfloat | GLenum} param
     */
    getParameter(pname: any, opts?: { ... }): any;
    getParameters(opts?: { ... }): { ... };

    /**
     * Update a Resource setting
     * @todo - cache parameter to avoid issuing WebGL calls?
     * @param {GLenum} pname - parameter (GL constant, value or key)
     * @param {GLint | GLfloat | GLenum} value
     * @return {Resource} returns self to enable chaining
     */
    setParameter(pname: any, value: any): this;
    setParameters(parameters: any): this;
    stubRemovedMethods(className: any, version: any, methodNames: any): void;
    initialize(opts: any): void;
    _createHandle(): void;
    _deleteHandle(handle?: any): void;
    _bindHandle(handle?: any): void;
    _getOptsFromHandle(): void;
    _getParameter(pname: any, opts: any): void;

    /**
     * @param {GLenum} pname
     * @param {GLint | GLfloat | GLenum} param
     * @return {Sampler} returns self to enable chaining
     */
    _setParameter(pname: any, value: any): void;
    _context(): any;
    _addStats(): void;
    _removeStats(): void;
    _trackAllocatedMemory(bytes: any, name?: string): void;
    _trackDeallocatedMemory(name?: string): void;
  }
}

declare module "@luma.gl/webgl/classes/accessor" {
  declare var DEFAULT_ACCESSOR_VALUES: {
    offset: number,
    stride: number,
    type: any,
    size: number,
    divisor: number,
    normalized: boolean,
    integer: boolean,
    ...
  };
  declare export default class Accessor {
    static getBytesPerElement(accessor: any): number;
    static getBytesPerVertex(accessor: any): number;
    static resolve(...accessors: any[]): Accessor;
    constructor(...accessors: any[]): this;
    toString(): string;
    BYTES_PER_ELEMENT: number;
    BYTES_PER_VERTEX: number;
    _assign(props?: { ... }): this;
  }
  declare export { DEFAULT_ACCESSOR_VALUES };
}

declare module "@luma.gl/webgl/classes/buffer" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class Buffer mixins Resource {
    constructor(gl: any, props?: { ... }): this;
    getElementCount(accessor?: any): number;
    getVertexCount(accessor?: any): number;
    initialize(props?: { ... }): this;
    setProps(props: any): this;
    setAccessor(accessor: any): this;
    reallocate(byteLength: any): boolean;
    setData(props: any): this;
    subData(props: any): this;
    copyData(x: {
      sourceBuffer: any,
      readOffset?: number,
      writeOffset?: number,
      size: any,
      ...
    }): this;
    getData(x?: {
      dstData?: any,
      srcByteOffset?: number,
      dstOffset?: number,
      length?: number,
      ...
    }): any;

    /**
     * Binds a buffer to a given binding point (target).
     *    GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.
     *    - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state
     *    - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.
     *    - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.
     */
    bind(x?: {
      target?: any,
      index?: any,
      offset?: number,
      size: any,
      ...
    }): this;
    unbind(x?: {
      target?: any,
      index?: any,
      ...
    }): this;
    getDebugData(): {
      data: any,
      changed: boolean,
      ...
    };
    invalidateDebugData(): void;
    _setData(data: any, offset?: number, byteLength?: any): this;
    _setByteLength(byteLength: any, usage?: any): this;
    _getTarget(): any;
    _getAvailableElementCount(srcByteOffset: any): number;
    _inferType(data: any): void;
    _createHandle(): any;
    _deleteHandle(): void;
    _getParameter(pname: any): any;
    type: any;
    bytes: any;
    setByteLength(byteLength: any): boolean;
    updateAccessor(opts: any): this;
  }
}

declare module "@luma.gl/webgl/classes/texture-formats" {
  declare export var TEXTURE_FORMATS: {
    [x: number]:
      | {
          dataFormat: any,
          types: any[],
          gl2?: void,
          ...
        }
      | {
          dataFormat: any,
          types: any[],
          gl2: boolean,
          ...
        },
    ...
  };
  declare export var DATA_FORMAT_CHANNELS: {
    [x: number]: number,
    ...
  };
  declare export var TYPE_SIZES: {
    [x: number]: number,
    ...
  };
  declare export function isFormatSupported(gl: any, format: any): any;

  declare export function isLinearFilteringSupported(gl: any, format: any): any;
}

declare module "@luma.gl/webgl/classes/texture" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class Texture mixins Resource {
    static isSupported(
      gl: any,
      x?: {
        format: any,
        linearFiltering: any,
        ...
      }
    ): boolean;
    constructor(gl: any, props: any): this;
    toString(): string;
    initialize(props?: { ... }): this | void;
    resize(x: {
      height: any,
      width: any,
      mipmaps?: boolean,
      ...
    }): this;
    generateMipmap(params?: { ... }): this;
    setImageData(options: any): this;

    /**
     * Redefines an area of an existing texture
     * Note: does not allocate storage
     */
    setSubImageData(x: {
      target?: any,
      pixels?: any,
      data?: any,
      x?: number,
      y?: number,
      width?: any,
      height?: any,
      level?: number,
      format?: any,
      type?: any,
      dataFormat?: any,
      compressed?: boolean,
      offset?: number,
      border?: any,
      parameters?: { ... },
      ...
    }): void;

    /**
     * Defines a two-dimensional texture image or cube-map texture image with
     * pixels from the current framebuffer (rather than from client memory).
     * (gl.copyTexImage2D wrapper)
     *
     * Note that binding a texture into a Framebuffer's color buffer and
     * rendering can be faster.
     */
    copyFramebuffer(opts?: { ... }): any;
    getActiveUnit(): number;
    bind(textureUnit?: any): any;
    unbind(textureUnit?: any): any;
    _getDataType(x: {
      data: any,
      compressed?: boolean,
      ...
    }): {
      data: any,
      dataType: string,
      ...
    };
    _deduceParameters(
      opts: any
    ): {
      dataFormat: any,
      type: any,
      compressed: any,
      width: any,
      height: any,
      format: any,
      data: any,
      ...
    };
    _deduceImageSize(data: any, width: any, height: any): any;
    _createHandle(): any;
    _deleteHandle(): void;
    _getParameter(pname: any): any;
    _setParameter(pname: any, param: any): this;
    _isNPOT(): boolean;
    _updateForNPOT(parameters: any): void;
    _getNPOTParam(pname: any, param: any): any;
  }
}

declare module "@luma.gl/webgl/utils/load-file" {
  declare export function setPathPrefix(prefix: any): void;

  declare export function loadFile(url: any, options?: { ... }): Promise<any>;

  declare export function loadImage(url: any, opts: any): Promise<mixed>;
}

declare module "@luma.gl/webgl/classes/texture-2d" {
  import typeof Texture from "@luma.gl/webgl/classes/texture";

  declare export default class Texture2D mixins Texture {
    static isSupported(gl: any, opts: any): boolean;
    constructor(gl: any, props?: { ... }): this;
  }
}

declare module "@luma.gl/webgl/classes/texture-cube" {
  import typeof Texture from "@luma.gl/webgl/classes/texture";

  declare export default class TextureCube mixins Texture {
    constructor(gl: any, props?: { ... }): this;
    initialize(props?: { ... }): void;
    subImage(x: {
      face: any,
      data: any,
      x?: number,
      y?: number,
      mipmapLevel?: number,
      ...
    }): any;
    setCubeMapImageData(x: {
      width: any,
      height: any,
      pixels: any,
      data: any,
      border?: number,
      format?: any,
      type?: any,
      ...
    }): Promise<void>;
    setImageDataForFace(options: any): this;
  }
}

declare module "@luma.gl/webgl/classes/texture-3d" {
  import typeof Texture from "@luma.gl/webgl/classes/texture";

  declare export default class Texture3D mixins Texture {
    static isSupported(gl: any): any;
    constructor(gl: any, props?: { ... }): this;
    setImageData(x: {
      level?: number,
      dataFormat?: any,
      width: any,
      height: any,
      depth?: number,
      border?: number,
      format: any,
      type?: any,
      offset?: number,
      data: any,
      parameters?: { ... },
      ...
    }): this;
  }
}

declare module "@luma.gl/webgl/classes/renderbuffer-formats" {
  declare var _default: {
    [x: number]:
      | {
          bpp: number,
          gl2?: void,
          ...
        }
      | {
          gl2: boolean,
          bpp: number,
          ...
        }
      | {
          gl2: string,
          bpp: number,
          ...
        },
    ...
  };
  declare export default typeof _default;
}

declare module "@luma.gl/webgl/classes/renderbuffer" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class Renderbuffer mixins Resource {
    static isSupported(
      gl: any,
      x?: {
        format: any,
        ...
      }
    ): any;
    static getSamplesForFormat(
      gl: any,
      x: {
        format: any,
        ...
      }
    ): any;
    constructor(gl: any, opts?: { ... }): this;
    initialize(x: {
      format: any,
      width?: number,
      height?: number,
      samples?: number,
      ...
    }): this;
    resize(x: {
      width: any,
      height: any,
      ...
    }): this;
    _createHandle(): any;
    _deleteHandle(): void;
    _bindHandle(handle: any): void;
    _syncHandle(handle: any): void;
    _getParameter(pname: any): any;
  }
}

declare module "@luma.gl/webgl/classes/clear" {
  declare export function clear(
    gl: any,
    x?: {
      framebuffer?: any,
      color?: any,
      depth?: any,
      stencil?: any,
      ...
    }
  ): void;

  declare export function clearBuffer(
    gl: any,
    x?: {
      framebuffer?: any,
      buffer?: number,
      drawBuffer?: number,
      value?: number[],
      ...
    }
  ): void;
}

declare module "@luma.gl/webgl/webgl-utils/format-utils" {
  declare export function glFormatToComponents(format: any): 1 | 0 | 2 | 4 | 3;

  declare export function glTypeToBytes(type: any): 1 | 0 | 2 | 4;
}

declare module "@luma.gl/webgl/classes/copy-and-blit" {
  declare export function readPixelsToArray(
    source: any,
    x?: {
      sourceX?: number,
      sourceY?: number,
      sourceFormat?: any,
      sourceAttachment?: any,
      target?: any,
      sourceWidth: any,
      sourceHeight: any,
      sourceType: any,
      ...
    }
  ): any;

  declare export function readPixelsToBuffer(
    source: any,
    x: {
      sourceX?: number,
      sourceY?: number,
      sourceFormat?: any,
      target?: any,
      targetByteOffset?: number,
      sourceWidth: any,
      sourceHeight: any,
      sourceType: any,
      ...
    }
  ): any;

  declare export function copyToDataUrl(
    source: any,
    x?: {
      sourceAttachment?: any,
      targetMaxHeight?: number,
      ...
    }
  ): string;

  declare export function copyToImage(
    source: any,
    x?: {
      sourceAttachment?: any,
      targetImage?: any,
      ...
    }
  ): any;

  declare export function copyToTexture(
    source: any,
    target: any,
    x?: {
      sourceX?: number,
      sourceY?: number,
      targetX: any,
      targetY: any,
      targetZ: any,
      targetMipmaplevel?: number,
      targetInternalFormat?: any,
      width: any,
      height: any,
      ...
    }
  ): any;

  declare export function blit(
    source: any,
    target: any,
    x?: {
      sourceAttachment?: any,
      sourceX0?: number,
      sourceY0?: number,
      sourceX1: any,
      sourceY1: any,
      targetX0?: number,
      targetY0?: number,
      targetX1: any,
      targetY1: any,
      color?: boolean,
      depth?: boolean,
      stencil?: boolean,
      mask?: number,
      filter?: any,
      ...
    }
  ): any;
}

declare module "@luma.gl/webgl/features/webgl-limits-table" {
  declare var _default: {
    [x: number]:
      | {
          gl1: Float32Array,
          gl2?: void,
          negative?: void,
          ...
        }
      | {
          gl1: number,
          gl2: number,
          negative?: void,
          ...
        }
      | {
          gl1: number,
          gl2?: void,
          negative?: void,
          ...
        }
      | {
          gl1: Int32Array,
          gl2?: void,
          negative?: void,
          ...
        }
      | {
          gl1: number,
          gl2: number,
          negative: boolean,
          ...
        },
    ...
  };
  declare export default typeof _default;
}

declare module "@luma.gl/webgl/features/limits" {
  declare export function getContextLimits(gl: any): any;

  declare export function getGLContextInfo(gl: any): any;

  declare export function getContextInfo(gl: any): any;
}

declare module "@luma.gl/webgl/features/webgl-features-table" {
  declare export var FEATURES: {
    WEBGL2: string,
    VERTEX_ARRAY_OBJECT: string,
    TIMER_QUERY: string,
    INSTANCED_RENDERING: string,
    MULTIPLE_RENDER_TARGETS: string,
    ELEMENT_INDEX_UINT32: string,
    BLEND_EQUATION_MINMAX: string,
    FLOAT_BLEND: string,
    COLOR_ENCODING_SRGB: string,
    TEXTURE_DEPTH: string,
    TEXTURE_FLOAT: string,
    TEXTURE_HALF_FLOAT: string,
    TEXTURE_FILTER_LINEAR_FLOAT: string,
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: string,
    TEXTURE_FILTER_ANISOTROPIC: string,
    COLOR_ATTACHMENT_RGBA32F: string,
    COLOR_ATTACHMENT_FLOAT: string,
    COLOR_ATTACHMENT_HALF_FLOAT: string,
    GLSL_FRAG_DATA: string,
    GLSL_FRAG_DEPTH: string,
    GLSL_DERIVATIVES: string,
    GLSL_TEXTURE_LOD: string,
    ...
  };
  declare function checkFloat32ColorAttachment(gl: any): boolean;

  declare var _default: {
    [x: string]:
      | (string | boolean)[]
      | (string | typeof checkFloat32ColorAttachment)[],
    ...
  };
  declare export default typeof _default;
}

declare module "@luma.gl/webgl/features/features" {
  declare export function hasFeature(gl: any, feature: any): any;

  declare export function hasFeatures(gl: any, features: any): any;

  declare export function getFeatures(gl: any): any;
}

declare module "@luma.gl/webgl/features/check-old-ie" {
  declare export default function isOldIE(opts?: { ... }): boolean;
}

declare module "@luma.gl/webgl/features/check-glsl-extension" {
  declare export default function canCompileGLGSExtension(
    gl: any,
    cap: any,
    options?: { ... }
  ): any;
}

declare module "features" {
  declare export {
    getContextInfo,
    getGLContextInfo,
    getContextLimits,
  } from "@luma.gl/webgl/features/limits";

  declare export { FEATURES } from "@luma.gl/webgl/features/webgl-features-table";

  declare export {
    hasFeature,
    hasFeatures,
    getFeatures,
  } from "@luma.gl/webgl/features/features";

  declare export { default as canCompileGLGSExtension } from "@luma.gl/webgl/features/check-glsl-extension";
}

declare module "@luma.gl/webgl/classes/framebuffer" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class Framebuffer mixins Resource {
    static isSupported(
      gl: any,
      x?: {
        colorBufferFloat: any,
        colorBufferHalfFloat: any,
        ...
      }
    ): boolean;
    static getDefaultFramebuffer(gl: any): any;
    MAX_COLOR_ATTACHMENTS: any;
    MAX_DRAW_BUFFERS: any;
    constructor(gl: any, opts?: { ... }): this;
    color: any;
    texture: any;
    depth: any;
    stencil: any;
    initialize(x: {
      width?: number,
      height?: number,
      attachments?: any,
      color?: boolean,
      depth?: boolean,
      stencil?: boolean,
      check?: boolean,
      readBuffer: any,
      drawBuffers: any,
      ...
    }): void;
    delete(): void;
    update(x: {
      attachments?: { ... },
      readBuffer: any,
      drawBuffers: any,
      clearAttachments?: boolean,
      resizeAttachments?: boolean,
      ...
    }): this;
    resize(x?: {
      width: any,
      height: any,
      ...
    }): this;
    attach(
      attachments: any,
      x?: {
        clearAttachments?: boolean,
        resizeAttachments?: boolean,
        ...
      }
    ): void;
    checkStatus(): this;
    getStatus(): any;
    clear(x?: {
      color: any,
      depth: any,
      stencil: any,
      drawBuffers?: any[],
      ...
    }): this;
    readPixels(opts?: { ... }): any;
    readPixelsToBuffer(opts?: { ... }): any;
    copyToDataUrl(opts?: { ... }): any;
    copyToImage(opts?: { ... }): any;
    copyToTexture(opts?: { ... }): any;
    blit(opts?: { ... }): any;
    invalidate(x: {
      attachments?: any[],
      x?: number,
      y?: number,
      width: any,
      height: any,
      ...
    }): this;
    getAttachmentParameter(attachment: any, pname: any, keys: any): any;
    getAttachmentParameters(
      attachment: any,
      keys: any,
      parameters?: any
    ): { ... };
    getParameters(keys?: boolean): { ... };
    show(): this;
    log(logLevel?: number, message?: string): this;
    bind(x?: {
      target?: any,
      ...
    }): this;
    unbind(x?: {
      target?: any,
      ...
    }): this;
    _createDefaultAttachments(
      color: any,
      depth: any,
      stencil: any,
      width: any,
      height: any
    ): any;
    _unattach(attachment: any): void;
    _attachRenderbuffer(x: {
      attachment?: any,
      renderbuffer: any,
      ...
    }): void;
    _attachTexture(x: {
      attachment?: any,
      texture: any,
      layer: any,
      level: any,
      ...
    }): void;
    _setReadBuffer(readBuffer: any): void;
    _setDrawBuffers(drawBuffers: any): void;
    _getAttachmentParameterFallback(pname: any): any;
    _createHandle(): any;
    _deleteHandle(): void;
    _bindHandle(handle: any): any;
  }
  declare export var FRAMEBUFFER_ATTACHMENT_PARAMETERS: any[];
}

declare module "@luma.gl/webgl/webgl-utils/texture-utils" {
  import typeof Framebuffer from "@luma.gl/webgl/classes/framebuffer";

  declare export function cloneTextureFrom(
    refTexture: any,
    overrides: any
  ): any;

  declare export function toFramebuffer(texture: any, opts: any): Framebuffer;
}

declare module "@luma.gl/webgl/glsl-utils/get-shader-name" {
  declare export default function getShaderName(
    shader: any,
    defaultName?: string
  ): any;
}

declare module "@luma.gl/webgl/glsl-utils/get-shader-type-name" {
  declare export default function getShaderTypeName(
    type: any
  ): "fragment" | "vertex" | "unknown type";
}

declare module "@luma.gl/webgl/glsl-utils/format-glsl-error" {
  declare export default function formatGLSLCompilerError(
    errLog: any,
    src: any,
    shaderType: any
  ): string;

  /**
   * Parse a GLSL compiler error log into a string showing the source code around each error.
   * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)
   */
  declare export function parseGLSLCompilerError(
    errLog: any,
    src: any,
    shaderType: any,
    shaderName: any
  ): {
    shaderName: string,
    errors: string,
    warnings: string,
    ...
  };
}

declare module "@luma.gl/webgl/glsl-utils/get-shader-version" {
  declare export default function getShaderVersion(source: any): number;
}

declare module "glsl-utils" {
  declare export {
    default as formatGLSLCompilerError,
    parseGLSLCompilerError,
  } from "@luma.gl/webgl/glsl-utils/format-glsl-error";

  declare export { default as getShaderName } from "@luma.gl/webgl/glsl-utils/get-shader-name";

  declare export { default as getShaderVersion } from "@luma.gl/webgl/glsl-utils/get-shader-version";

  declare export { default as getShaderTypeName } from "@luma.gl/webgl/glsl-utils/get-shader-type-name";
}

declare module "@luma.gl/webgl/classes/shader" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export class Shader mixins Resource {
    static getTypeName(
      shaderType: any
    ): "vertex-shader" | "fragment-shader" | "unknown";
    constructor(gl: any, props: any): this;
    initialize(x: {
      source: any,
      ...
    }): void;
    getParameter(pname: any): any;
    toString(): string;
    getName(): any;
    getSource(): any;
    getTranslatedSource(): any;
    _compile(source?: any): void;
    _deleteHandle(): void;
    _getOptsFromHandle(): {
      type: any,
      source: any,
      ...
    };
  }
  declare export class VertexShader mixins Shader {
    constructor(gl: any, props: any): this;
    _createHandle(): any;
  }
  declare export class FragmentShader mixins Shader {
    constructor(gl: any, props: any): this;
    _createHandle(): any;
  }
}

declare module "@luma.gl/webgl/classes/uniforms" {
  declare export function parseUniformName(
    name: any
  ): {
    name: any,
    length: any,
    isArray: boolean,
    ...
  };

  declare export function getUniformSetter(
    gl: any,
    location: any,
    info: any
  ): any;

  declare export function checkUniformValues(
    uniforms: any,
    source: any,
    uniformMap: any
  ): boolean;

  /**
   * Creates a copy of the uniform
   */
  declare export function copyUniform(
    uniforms: any,
    key: any,
    value: any
  ): void;
}

declare module "@luma.gl/webgl/webgl-utils/attribute-utils" {
  declare export function getPrimitiveDrawMode(drawMode: any): 1 | 0 | 4;

  declare export function getPrimitiveCount(x: {
    drawMode: any,
    vertexCount: any,
    ...
  }): any;

  declare export function getVertexCount(x: {
    drawMode: any,
    vertexCount: any,
    ...
  }): any;

  declare export function decomposeCompositeGLType(
    compositeGLType: any
  ): {
    type: any,
    components: any,
    ...
  };

  declare export function getCompositeGLType(
    type: any,
    components: any
  ): {
    glType: string,
    name: any,
    ...
  };
}

declare module "@luma.gl/webgl/classes/program-configuration" {
  declare export default class ProgramConfiguration {
    constructor(program: any): this;
    getAttributeInfo(locationOrName: any): any;
    getAttributeLocation(locationOrName: any): any;
    getAttributeAccessor(locationOrName: any): any;
    getVaryingInfo(locationOrName: any): any;
    getVaryingIndex(locationOrName: any): any;
    getVaryingAccessor(locationOrName: any): any;
    _readAttributesFromProgram(program: any): void;
    _readVaryingsFromProgram(program: any): void;
    _addAttribute(
      location: any,
      name: any,
      compositeType: any,
      size: any
    ): void;
    _inferProperties(location: any, name: any, accessor: any): void;
    _addVarying(location: any, name: any, compositeType: any, size: any): void;
  }
}

declare module "@luma.gl/webgl/classes/program" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class Program mixins Resource {
    constructor(gl: any, props?: { ... }): this;
    initialize(props?: { ... }): this;
    delete(options?: { ... }): this;
    setProps(props: any): this;
    draw(x: {
      logPriority: any,
      drawMode?: any,
      vertexCount: any,
      offset?: number,
      start: any,
      end: any,
      isIndexed?: boolean,
      indexType?: any,
      instanceCount?: number,
      isInstanced?: boolean,
      vertexArray?: any,
      transformFeedback: any,
      framebuffer: any,
      parameters?: { ... },
      uniforms: any,
      samplers: any,
      ...
    }): boolean;
    setUniforms(uniforms?: { ... }): this;
    _areTexturesRenderable(): any;
    _bindTextures(): void;
    _createHandle(): any;
    _deleteHandle(): void;
    _getOptionsFromHandle(handle: any): { ... };
    _getParameter(pname: any): any;
    _setId(id: any): void;
    _getName(): any;
    _compileAndLink(): void;
    _readUniformLocationsFromLinkedProgram(): void;
    getActiveUniforms(uniformIndices: any, pname: any): any;
    getUniformBlockIndex(blockName: any): any;
    getActiveUniformBlockParameter(blockIndex: any, pname: any): any;
    uniformBlockBinding(blockIndex: any, blockBinding: any): void;
  }
}

declare module "@luma.gl/webgl/classes/query" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class Query mixins Resource {
    static isSupported(gl: any, opts?: any[]): any;
    constructor(gl: any, opts?: { ... }): this;
    beginTimeElapsedQuery(): this;
    beginOcclusionQuery(x?: {
      conservative?: boolean,
      ...
    }): this;
    beginTransformFeedbackQuery(): this;
    begin(target: any): this;
    end(): this;
    isResultAvailable(): any;
    isTimerDisjoint(): any;
    getResult(): any;
    getTimerMilliseconds(): number;
    createPoll(limit?: number): any;
    _createHandle(): any;
    _deleteHandle(): void;
  }
}

declare module "@luma.gl/webgl/classes/transform-feedback" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class TransformFeedback mixins Resource {
    static isSupported(gl: any): any;
    constructor(gl: any, props?: { ... }): this;
    initialize(props?: { ... }): this;
    setProps(props: any): void;
    setBuffers(buffers?: { ... }): this;
    setBuffer(locationOrName: any, bufferOrParams: any): this;
    begin(primitiveMode?: any): this;
    end(): this;
    _getBufferParams(
      bufferOrParams: any
    ): {
      buffer: any,
      byteOffset: any,
      byteSize: any,
      ...
    };
    _getVaryingInfo(locationOrName: any): any;
    _getVaryingIndex(locationOrName: any): any;
    _bindBuffers(): void;
    _unbindBuffers(): void;
    _bindBuffer(
      index: any,
      buffer: any,
      byteOffset: number,
      byteSize: any
    ): this;
    _createHandle(): any;
    _deleteHandle(): void;
    _bindHandle(handle: any): void;
  }
}

declare module "@luma.gl/webgl/utils/array-utils-flat" {
  declare export function getScratchArrayBuffer(byteLength: any): any;

  declare export function getScratchArray(Type: any, length: any): any;

  declare export function fillArray(x: {
    target: any,
    source: any,
    start?: number,
    count?: number,
    ...
  }): any;
}

declare module "@luma.gl/webgl/classes/vertex-array-object" {
  import typeof Resource from "@luma.gl/webgl/classes/resource";

  declare export default class VertexArrayObject mixins Resource {
    static isSupported(gl: any, options?: { ... }): any;
    static getDefaultArray(gl: any): any;
    static getMaxAttributes(gl: any): any;
    static setConstant(gl: any, location: any, array: any): void;
    constructor(gl: any, opts?: { ... }): this;
    delete(): void;
    MAX_ATTRIBUTES: any;
    initialize(props?: { ... }): this;
    setProps(props: any): this;
    setElementBuffer(elementBuffer?: any, opts?: { ... }): this;
    setBuffer(location: any, buffer: any, accessor: any): this;
    enable(location: any, enable?: boolean): this;
    getConstantBuffer(elementCount: any, value: any, accessor: any): any;
    _normalizeConstantArrayValue(arrayValue: any, accessor: any): any;
    _compareConstantArrayValues(v1: any, v2: any): boolean;
    static _setConstantFloatArray(gl: any, location: any, array: any): void;
    static _setConstantIntArray(gl: any, location: any, array: any): void;
    static _setConstantUintArray(gl: any, location: any, array: any): void;
    _createHandle(): any;
    _deleteHandle(handle: any): any[];
    _bindHandle(handle: any): void;
    _getParameter(
      pname: any,
      x: {
        location: any,
        ...
      }
    ): any;
  }
}

declare module "@luma.gl/webgl/classes/vertex-array" {
  import typeof Accessor from "@luma.gl/webgl/classes/accessor";

  declare export default class VertexArray {
    constructor(gl: any, opts?: { ... }): this;
    delete(): void;
    initialize(props?: { ... }): this;
    reset(): this;
    setProps(props: any): this;
    clearDrawParams(): void;
    getDrawParams(): any;
    setAttributes(attributes: any): this;
    setElementBuffer(elementBuffer?: any, accessor?: { ... }): this;
    setBuffer(locationOrName: any, buffer: any, appAccessor?: { ... }): this;
    setConstant(
      locationOrName: any,
      arrayValue: any,
      appAccessor?: { ... }
    ): this;
    unbindBuffers(): this;
    bindBuffers(): this;
    bindForDraw(vertexCount: any, instanceCount: any, func: any): any;
    _resolveLocationAndAccessor(
      locationOrName: any,
      value: any,
      valueAccessor: any,
      appAccessor: any
    ):
      | this
      | {
          location: any,
          accessor: Accessor,
          ...
        };
    _getAttributeInfo(attributeName: any): any;
    _getAttributeIndex(
      locationOrName: any
    ):
      | {
          location: number,
          name?: void,
          ...
        }
      | {
          location: any,
          name: any,
          ...
        };
    _setAttribute(locationOrName: any, value: any): void;
    _setConstantAttributes(vertexCount: any, instanceCount: any): void;
    _setConstantAttributeZero(constant: any, elementCount: any): void;
    _setConstantAttribute(location: any, constant: any): void;
    _updateDrawParams(): {
      isIndexed: boolean,
      isInstanced: boolean,
      indexCount: number,
      vertexCount: number,
      instanceCount: number,
      ...
    };
    _updateDrawParamsForLocation(drawParams: any, location: any): void;
    setElements(elementBuffer?: any, accessor?: { ... }): this;
  }
}

declare module "@luma.gl/webgl/classes/uniform-buffer-layout" {
  declare export default class UniformBufferLayout {
    constructor(layout: any): this;
    getBytes(): number;
    getData(): any;
    getSubData(
      index: any
    ): {
      data: any,
      offset: any,
      ...
    };
    setUniforms(values: any): this;
    _setValue(key: any, value: any): void;
    _addUniform(key: any, uniformType: any): void;
    _alignTo(size: any, count: any): any;
  }
}

declare module "@luma.gl/webgl/debug/debug-uniforms" {
  declare export function getDebugTableForUniforms(x?: {
    header?: string,
    program: any,
    uniforms: any,
    undefinedOnly?: boolean,
    ...
  }): {
    table: { ... },
    count: number,
    unusedTable: { ... },
    unusedCount: number,
    ...
  };
}

declare module "@luma.gl/webgl/debug/debug-vertex-array" {
  declare export function getDebugTableForVertexArray(x?: {
    vertexArray: any,
    header?: string,
    ...
  }): { ... };
}

declare module "@luma.gl/webgl/debug/debug-program-configuration" {
  declare export function getDebugTableForProgramConfiguration(
    config: any
  ): { ... };
}

declare module "@luma.gl/webgl/webgl-utils/get-error" {
  declare export function glGetError(gl: any): Error;

  declare export function glCheckError(gl: any): void;
}
