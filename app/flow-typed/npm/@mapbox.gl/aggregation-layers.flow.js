/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.11.0
 * @flow
 */

declare module "@deck.gl/aggregation-layers/utils/prop-utils" {
  declare export function filterProps(props: any, filterKeys: any): { ... };
}

declare module "@deck.gl/aggregation-layers/aggregation-layer" {
  import type { CompositeLayer } from "@deck.gl/core";

  import type { CompositeLayerProps } from "@deck.gl/core/lib/composite-layer";

  declare export type AggregationLayerProps<D> = {
    ...
  } & CompositeLayerProps<D>;

  declare export default class AggregationLayer<
      D,
      P: AggregationLayerProps<D> = AggregationLayerProps<D>
    >
    mixins CompositeLayer<D, P> {
    constructor(props: AggregationLayerProps<D>): this;
    initializeState(dimensions: any): void;
    updateState(opts: any): void;
    updateAttributes(changedAttributes: any): void;
    getAttributes(): any;
    getModuleSettings(): any;
    updateShaders(shaders: any): void;

    /**
     * Checks if aggregation is dirty
     * @param {Object} updateOpts - object {props, oldProps, changeFlags}
     * @param {object} params - object {dimension, compareAll}
     * @param {Object} params.dimension - {props, accessors} array of props and/or accessors
     * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision
     * @returns {Boolean} - returns true if dimensions' prop or accessor is changed
     */
    isAggregationDirty(updateOpts: any, params?: { ... }): any;

    /**
 * Checks if an attribute is changed
 * @param {String} name - name of the attribute
 * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,
   If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise
 */
    isAttributeChanged(name: any): boolean;
    _getAttributeManager(): any;
  }
}

declare module "@deck.gl/aggregation-layers/utils/aggregation-operation-utils" {
  declare export type AggregationOperation = "SUM" | "MEAN" | "MIN" | "MAX";
  declare export var AGGREGATION_OPERATION: {
    SUM: number,
    MEAN: number,
    MIN: number,
    MAX: number,
    ...
  };
  declare export function getMean(pts: any, accessor: any): number;

  declare export function getSum(pts: any, accessor: any): any;

  declare export function getMax(pts: any, accessor: any): any;

  declare export function getMin(pts: any, accessor: any): any;

  declare export function getValueFunc(
    aggregation: any,
    accessor: any
  ): (pts: any) => any;
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants" {
  declare export var DEFAULT_RUN_PARAMS: {
    projectPoints: boolean,
    viewport: any,
    createBufferObjects: boolean,
    moduleSettings: { ... },
    ...
  };
  declare export var MAX_32_BIT_FLOAT: any; // 3.402823466e+38
  declare export var MIN_BLEND_EQUATION: any[];
  declare export var MAX_BLEND_EQUATION: any[];
  declare export var MAX_MIN_BLEND_EQUATION: any[];
  declare export var EQUATION_MAP: {
    [x: number]: any,
    ...
  };
  declare export var ELEMENTCOUNT: any; // 4
  declare export var DEFAULT_WEIGHT_PARAMS: {
    size: number,
    operation: number,
    needMin: boolean,
    needMax: boolean,
    combineMaxMin: boolean,
    ...
  };
  declare export var PIXEL_SIZE: any; // 4
  declare export var WEIGHT_SIZE: any; // 3
  declare export var MAX_MIN_TEXTURE_OPTS: {
    format: any,
    type: any,
    border: number,
    mipmaps: boolean,
    parameters: {
      [x: number]: any,
      ...
    },
    dataFormat: any,
    width: number,
    height: number,
    ...
  };
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/aggregate-all-vs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/aggregate-all-fs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/transform-mean-vs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/utils/resource-utils" {
  declare export function getFloatTexture(gl: any, opts?: { ... }): any;

  declare export function getFramebuffer(gl: any, opts: any): any;

  declare export function getFloatArray(
    array: any,
    size: any,
    fillValue?: number
  ): any;
}

declare module "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/gpu-grid-aggregator" {
  declare export default class GPUGridAggregator {
    static getAggregationData(x: {
      aggregationData: any,
      maxData: any,
      minData: any,
      maxMinData: any,
      pixelIndex: any,
      ...
    }): { ... };
    static getCellData(x: {
      countsData: any,
      size?: number,
      ...
    }): {
      cellCounts: Uint32Array,
      cellWeights: Float32Array,
      ...
    };
    static isSupported(gl: any): any;
    constructor(gl: any, opts?: { ... }): this;
    delete(): void;
    run(opts?: { ... }): { ... };
    getData(weightId: any): { ... };
    updateShaders(shaderOptions?: { ... }): void;
    _normalizeAggregationParams(opts: any): any;
    setState(updateObject: any): void;
    _getAggregateData(opts: any): { ... };
    _renderAggregateData(opts: any): void;
    _renderToMaxMinTexture(opts: any): void;
    _renderToWeightsTexture(opts: any): void;
    _runAggregation(opts: any): { ... };
    _setupFramebuffers(opts: any): void;
    _getMinMaxTexture(name: any): any;
    _setupModels(x?: {
      numCol?: number,
      numRow?: number,
      ...
    }): void;
    _setupWeightAttributes(opts: any): void;
    _trackGPUResultBuffers(results: any, weights: any): void;
    _updateModels(opts: any): void;
  }
}

declare module "@deck.gl/aggregation-layers/utils/scale-utils" {
  declare export function getScale(
    domain: any,
    range: any,
    scaleFunction: any
  ): any;

  declare export function getQuantizeScale(domain: any, range: any): any;

  declare export function getLinearScale(domain: any, range: any): any;

  declare export function getQuantileScale(domain: any, range: any): any;

  declare export function getOrdinalScale(domain: any, range: any): any;

  declare export function quantizeScale(
    domain: any,
    range: any,
    value: any
  ): any;

  declare export function linearScale(domain: any, range: any, value: any): any;

  declare export function unique(values: any): any[];

  declare export function getLinearDomain(data: any, valueAccessor: any): any[];

  declare export function getQuantileDomain(data: any, valueAccessor: any): any;

  declare export function getOrdinalDomain(
    data: any,
    valueAccessor: any
  ): any[];

  declare export function getScaleDomain(
    scaleType: any,
    data: any,
    valueAccessor: any
  ): any;

  declare export function clamp(value: any, min: any, max: any): number;

  declare export function getScaleFunctionByScaleType(
    scaleType: any
  ): typeof getQuantizeScale;
}

declare module "@deck.gl/aggregation-layers/utils/bin-sorter" {
  declare export default class BinSorter {
    constructor(
      bins?: any[],
      props?: {
        getValue: (points: any) => any,
        getPoints: (bin: any) => any,
        getIndex: (bin: any) => any,
        filterData: any,
        ...
      }
    ): this;

    /**
     * Get an array of object with aggregated values and index of bins
     * Array object will be sorted by value optionally.
     * @param {Array} bins
     * @param {Function} getValue
     * @return {Array} array of values and index lookup
     */
    getAggregatedBins(bins: any, props: any): any[];
    _percentileToIndex(percentileRange: any): number[];

    /**
     * Get a mapping from cell/hexagon index to sorted bin
     * This is used to retrieve bin value for color calculation
     * @return {Object} bin index to aggregatedBins
     */
    getBinMap(): { ... };

    /**
     * Get ths max count of all bins
     * @return {Number | Boolean} max count
     */
    _updateMinMaxValues(): void;

    /**
     * Get range of values of all bins
     * @param {Number[]} range
     * @param {Number} range 0] - lower bound
     * @param {Number} range 1] - upper bound
     * @return {Array} array of new value range
     */
    getValueRange(percentileRange: any): any[];
    getValueDomainByScale(scale: any, x?: [number | void, number | void]): any;
    _getScaleDomain(scaleType: any, x: [any, any]): any;
  }
}

declare module "@deck.gl/aggregation-layers/utils/grid-aggregation-utils" {
  declare export function getBoundingBox(
    attributes: any,
    vertexCount: any
  ): {
    xMin: any,
    xMax: any,
    yMin: any,
    yMax: any,
    ...
  };

  declare export function alignToCell(inValue: any, cellSize: any): number;

  /**
   * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space
   * @param {{[key: string]: any}} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data
   * @param {number} cellSize - grid cell size in meters
   * @param {boolean}  , optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space
   * @returns {xOffset} , yOffset} - cellSize size
   */
  declare export function getGridOffset(
    boundingBox: any,
    cellSize: any,
    convertToMeters?: boolean
  ): {
    xOffset: any,
    yOffset: any,
    ...
  };

  declare export function getGridParams(
    boundingBox: any,
    cellSize: any,
    viewport: any,
    coordinateSystem: any
  ): {
    gridOffset: {
      xOffset: any,
      yOffset: any,
      ...
    },
    translation: number[],
    width: any,
    height: any,
    numCol: number,
    numRow: number,
    ...
  };
}

declare module "@deck.gl/aggregation-layers/cpu-grid-layer/grid-aggregator" {
  /**
   * Calculate density grid from an array of points
   * @param {object} props - object containing :
   * @param {Iterable} [props.data] - data objects to be aggregated
   * @param {Integer} [props.cellSize] - size of the grid cell
   * @param {Object} aggregationParams - object containing :
   * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters
   * @param {Integer} width - width of the grid
   * @param {Integer} height - height of the grid
   * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise
   * @param {Array} attributes - attributes array containing position values
   * @param {Viewport} viewport - viewport to be used for projection
   * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index
   * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data
   * @returns {{[key: string]: any}} - grid data, cell dimension
   */
  declare export function pointToDensityGridDataCPU(
    props: any,
    aggregationParams: any
  ): {
    gridHash: { ... } | { ... },
    gridOffset: any,
    data: any[],
    ...
  };
}

declare module "@deck.gl/aggregation-layers/grid-aggregation-layer" {
  import type AggregationLayer, {
    AggregationLayerProps,
  } from "@deck.gl/aggregation-layers/aggregation-layer";

  declare export type GridAggregationLayerProps<D> = {
    ...
  } & AggregationLayerProps<D>;

  declare export default class GridAggregationLayer<
      D,
      P: GridAggregationLayerProps<D> = GridAggregationLayerProps<D>
    >
    mixins AggregationLayer<D, P> {
    constructor(props: GridAggregationLayerProps<D>): this;
    initializeState(x: {
      dimensions: any,
      ...
    }): void;
    updateState(opts: any): void;
    finalizeState(): void;
    updateShaders(shaders: any): void;
    updateAggregationState(opts: any): void;
    allocateResources(numRow: any, numCol: any): void;
    updateResults(x: {
      aggregationData: any,
      maxMinData: any,
      maxData: any,
      minData: any,
      ...
    }): void;
    _updateAggregation(opts: any): void;
    _updateWeightBins(): void;
    _uploadAggregationResults(): void;
  }
}

declare module "@deck.gl/aggregation-layers/utils/color-utils" {
  declare export var defaultColorRange: number[][];
  declare export function colorRangeToFlatArray(
    colorRange: any,
    normalize?: boolean,
    ArrayType?: Float32ArrayConstructor
  ): any;
}

declare module "@deck.gl/aggregation-layers/screen-grid-layer/screen-grid-layer-vertex.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/screen-grid-layer/screen-grid-layer-fragment.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/screen-grid-layer/screen-grid-cell-layer" {
  import type { Layer } from "@deck.gl/core";

  import type { LayerProps } from "@deck.gl/core/lib/layer";

  declare export type ScreenGridCellLayerProps<D> = { ... } & LayerProps<D>;

  declare export default class ScreenGridCellLayer<
      D,
      P: ScreenGridCellLayerProps<D> = ScreenGridCellLayerProps<D>
    >
    mixins Layer<D, P> {
    static isSupported(gl: any): any;
    getShaders(): {
      vs: string,
      fs: string,
      modules: any[],
      ...
    };
    initializeState(params: any): void;
    shouldUpdateState(x: {
      changeFlags: any,
      ...
    }): any;
    updateState(x: {
      oldProps: ScreenGridCellLayerProps<D>,
      props: ScreenGridCellLayerProps<D>,
      changeFlags: any,
      ...
    }): void;
    draw(x: {
      uniforms: any,
      ...
    }): void;
    calculateInstancePositions(
      attribute: any,
      x: {
        numInstances: any,
        ...
      }
    ): void;
    _getModel(gl: any): any;
    _shouldUseMinMax(): boolean;
    _updateUniforms(oldProps: any, props: any, changeFlags: any): void;
  }
}

declare module "@deck.gl/aggregation-layers/screen-grid-layer/screen-grid-layer" {
  import typeof GridAggregationLayer from "@deck.gl/aggregation-layers/grid-aggregation-layer";

  import type { LayerProps } from "@deck.gl/core/lib/layer";

  import type { ColorDomain, ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type ScreenGridLayerProps<D> = {
    cellSizePixels?: number,
    cellMarginPixels?: number,
    colorDomain?: ColorDomain,
    colorRange?: ColorRange,
    gpuAggregation?: boolean,
    aggregation?: string,
    getPosition?: (d: D) => Position,
    getWeight?: (d: D) => number,
    ...
  } & LayerProps<D>;

  declare export default class ScreenGridLayer<
      D,
      P: ScreenGridLayerProps<D> = ScreenGridLayerProps<D>
    >
    mixins GridAggregationLayer<D, P> {
    constructor(props: ScreenGridLayerProps<D>): this;
    initializeState(params: any): void;
    shouldUpdateState(x: {
      changeFlags: any,
      ...
    }): any;
    updateState(opts: any): void;
    renderLayers(): any;
    finalizeState(): void;
    getPickingInfo(x: {
      info: any,
      mode: any,
      ...
    }): any;
    updateResults(x: {
      aggregationData: any,
      maxData: any,
      ...
    }): void;
    updateAggregationState(opts: any): void;
    _updateAccessors(opts: any): void;
    _resetResults(): void;
  }
}

declare module "@deck.gl/aggregation-layers/utils/cpu-aggregator" {
  declare export default class CPUAggregator {
    constructor(opts: any): this;
    static defaultDimensions(): (
      | {
          key: string,
          accessor: string,
          pickingInfo: string,
          getBins: {
            triggers: {
              value: {
                prop: string,
                updateTrigger: string,
                ...
              },
              weight: {
                prop: string,
                updateTrigger: string,
                ...
              },
              aggregation: {
                prop: string,
                ...
              },
              filterData: {
                prop: string,
                updateTrigger: string,
                ...
              },
              ...
            },
            ...
          },
          getDomain: {
            triggers: {
              lowerPercentile: {
                prop: string,
                ...
              },
              upperPercentile: {
                prop: string,
                ...
              },
              scaleType: {
                prop: string,
                ...
              },
              ...
            },
            ...
          },
          getScaleFunc: {
            triggers: {
              domain: {
                prop: string,
                ...
              },
              range: {
                prop: string,
                ...
              },
              ...
            },
            onSet: {
              props: string,
              ...
            },
            ...
          },
          nullValue: number[],
          ...
        }
      | {
          key: string,
          accessor: string,
          pickingInfo: string,
          getBins: {
            triggers: {
              value: {
                prop: string,
                updateTrigger: string,
                ...
              },
              weight: {
                prop: string,
                updateTrigger: string,
                ...
              },
              aggregation: {
                prop: string,
                ...
              },
              filterData: {
                prop: string,
                updateTrigger: string,
                ...
              },
              ...
            },
            ...
          },
          getDomain: {
            triggers: {
              lowerPercentile: {
                prop: string,
                ...
              },
              upperPercentile: {
                prop: string,
                ...
              },
              scaleType: {
                prop: string,
                ...
              },
              ...
            },
            ...
          },
          getScaleFunc: {
            triggers: {
              domain: {
                prop: string,
                ...
              },
              range: {
                prop: string,
                ...
              },
              ...
            },
            onSet: {
              props: string,
              ...
            },
            ...
          },
          nullValue: number,
          ...
        }
    )[];
    updateState(opts: any, aggregationParams: any): any;
    setState(updateObject: any): void;
    setDimensionState(key: any, updateObject: any): void;
    normalizeResult(result?: { ... }): { ... };
    getAggregatedData(props: any, aggregationParams: any): void;
    updateGetValueFuncs(oldProps: any, props: any, changeFlags: any): void;
    needsReProjectPoints(oldProps: any, props: any, changeFlags: any): any;
    addDimension(dimensions: any): void;
    _addDimension(dimensions?: any[]): void;
    getDimensionUpdaters(x: {
      key: any,
      accessor: any,
      pickingInfo: any,
      getBins: any,
      getDomain: any,
      getScaleFunc: any,
      nullValue: any,
      ...
    }): {
      key: any,
      accessor: any,
      pickingInfo: any,
      getBins: any,
      getDomain: any,
      getScaleFunc: any,
      attributeAccessor: (cell: any) => any,
      ...
    };
    needUpdateDimensionStep(
      dimensionStep: any,
      oldProps: any,
      props: any,
      changeFlags: any
    ): boolean;
    getDimensionChanges(oldProps: any, props: any, changeFlags: any): any[];
    getUpdateTriggers(props: any): { ... };
    getSortedBins(props: any): void;
    getDimensionSortedBins(props: any, dimensionUpdater: any): void;
    getDimensionValueDomain(props: any, dimensionUpdater: any): void;
    getDimensionScale(props: any, dimensionUpdater: any): void;
    getSubLayerDimensionAttribute(key: any, nullValue: any): (cell: any) => any;
    getSubLayerAccessors(props: any): { ... };
    getPickingInfo(x: {
      info: any,
      ...
    }): any;
    getAccessor(dimensionKey: any): any;
  }
}

declare module "@deck.gl/aggregation-layers/cpu-grid-layer/cpu-grid-layer" {
  import type AggregationLayer, {
    AggregationLayerProps,
  } from "@deck.gl/aggregation-layers/aggregation-layer";

  import type { AggregationOperation } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  import type { ColorDomain, ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type CPUGridLayerProps<D> = {
    cellSize?: number,
    colorDomain?: ColorDomain,
    colorRange?: ColorRange,
    coverage?: number,
    elevationDomain?: [number, number],
    elevationRange?: [number, number],
    elevationScale?: number,
    extruded?: boolean,
    upperPercentile?: number,
    lowerPercentile?: number,
    elevationUpperPercentile?: number,
    elevationLowerPercentile?: number,
    colorScaleType?: string,
    material?: Object,
    getPosition?: (d: D) => Position,
    getColorValue?: (d: D[]) => number,
    getColorWeight?: (d: D) => number,
    colorAggregation?: string,
    getElevationValue?: (points: D[]) => number,
    getElevationWeight?: (d: D) => number,
    elevationAggregation?: AggregationOperation,
    onSetColorDomain?: () => void,
    onSetElevationDomain?: () => void,
    ...
  } & AggregationLayerProps<D>;

  declare export default class CPUGridLayer<
      D,
      P: CPUGridLayerProps<D> = CPUGridLayerProps<D>
    >
    mixins AggregationLayer<D, P> {
    constructor(props: CPUGridLayerProps<D>): this;
    initializeState(params: any): void;
    updateState(opts: any): void;
    getPickingInfo(x: {
      info: any,
      ...
    }): any;
    _onGetSublayerColor(cell: any): any;
    _onGetSublayerElevation(cell: any): any;
    _getSublayerUpdateTriggers(): any;
    renderLayers(): any;
  }
}

declare module "@deck.gl/aggregation-layers/hexagon-layer/hexagon-aggregator" {
  /**
   * Use d3-hexbin to performs hexagonal binning from geo points to hexagons
   * @param {Iterable} data - array of points
   * @param {Number} radius - hexagon radius in meter
   * @param {function} getPosition - get points lon lat
   * @param {Object} viewport - current viewport object
   * @return {Object} - hexagons and countRange
   */
  declare export function pointToHexbin(
    props: any,
    aggregationParams: any
  ): {
    hexagons: any,
    radiusCommon: number,
    ...
  };

  /**
   * Get the bounding box of all data points
   */
  declare export function getPointsCenter(
    data: any,
    aggregationParams: any
  ): number[];

  /**
   * Get radius in mercator world space coordinates from meter
   * @param {Number} radius - in meter
   * @param {Object} viewport - current viewport object
   * @param {Array<Number>} center - data center
   * @return {Number} radius in mercator world spcae coordinates
   */
  declare export function getRadiusInCommon(
    radius: any,
    viewport: any,
    center: any
  ): number;
}

declare module "@deck.gl/aggregation-layers/hexagon-layer/hexagon-layer" {
  import type AggregationLayer, {
    AggregationLayerProps,
  } from "@deck.gl/aggregation-layers/aggregation-layer";

  import type { AggregationOperation } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  import type { ColorDomain, ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type HexagonLayerProps<D> = {
    radius?: number,
    hexagonAggregator?: Function,
    colorDomain?: ColorDomain,
    colorRange?: ColorRange,
    coverage?: number,
    elevationDomain?: [number, number],
    elevationRange?: [number, number],
    elevationScale?: number,
    extruded?: boolean,
    upperPercentile?: number,
    lowerPercentile?: number,
    elevationUpperPercentile?: number,
    elevationLowerPercentile?: number,
    material?: Object,
    getPosition?: (d: D) => Position,
    getColorValue?: (d: D[]) => any,
    getColorWeight?: (d: D) => any,
    colorAggregation?: string,
    getElevationValue?: (d: D) => any,
    getElevationWeight?: (d: D) => any,
    elevationAggregation?: AggregationOperation,
    onSetColorDomain?: Function,
    onSetElevationDomain?: Function,
    ...
  } & AggregationLayerProps<D>;

  declare export default class HexagonLayer<
      D,
      P: HexagonLayerProps<D> = HexagonLayerProps<D>
    >
    mixins AggregationLayer<D, P> {
    constructor(props: HexagonLayerProps<D>): this;
    shouldUpdateState(x: {
      changeFlags: any,
      ...
    }): any;
    initializeState(params: any): void;
    updateState(opts: any): void;
    updateRadiusAngle(vertices: any): void;
    convertLatLngToMeterOffset(hexagonVertices: any): number[][];
    getPickingInfo(x: {
      info: any,
      ...
    }): any;
    _onGetSublayerColor(cell: any): any;
    _onGetSublayerElevation(cell: any): any;
    _getSublayerUpdateTriggers(): any;
    renderLayers(): any;
  }
}

declare module "@deck.gl/aggregation-layers/contour-layer/marching-squares-codes" {
  declare export var ISOLINES_CODE_OFFSET_MAP: {
    0: any[],
    1: number[][][],
    2: number[][][],
    3: number[][][],
    4: number[][][],
    5: {
      0: number[][][],
      1: number[][][],
      ...
    },
    6: number[][][],
    7: number[][][],
    8: number[][][],
    9: number[][][],
    10: {
      0: number[][][],
      1: number[][][],
      ...
    },
    11: number[][][],
    12: number[][][],
    13: number[][][],
    14: number[][][],
    15: any[],
    ...
  };
  declare export var ISOBANDS_CODE_OFFSET_MAP: {
    [x: number]:
      | number[][][]
      | {
          0: number[][][],
          1: number[][][],
          2: number[][][],
          ...
        },
    ...
  };
}

declare module "@deck.gl/aggregation-layers/contour-layer/marching-squares" {
  declare export var CONTOUR_TYPE: {
    ISO_LINES: number,
    ISO_BANDS: number,
    ...
  };
  declare export function getCode(
    opts: any
  ): {
    code: number,
    meanCode: number,
    ...
  };

  declare export function getVertices(opts: any): any[];
}

declare module "@deck.gl/aggregation-layers/contour-layer/contour-utils" {
  declare export function generateContours(x: {
    thresholdData: any,
    colors: any,
    cellWeights: any,
    gridSize: any,
    gridOrigin: any,
    cellSize: any,
    ...
  }): {
    contourSegments: any[],
    contourPolygons: any[],
    ...
  };
}

declare module "@deck.gl/aggregation-layers/contour-layer/contour-layer" {
  import type GridAggregationLayer, {
    GridAggregationLayerProps,
  } from "@deck.gl/aggregation-layers/grid-aggregation-layer";

  import type { AggregationOperation } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type ContourLayerProps<D> = {
    cellSize?: number,
    gpuAggregation?: boolean,
    aggregation?: AggregationOperation,
    contours?: Array<any>,
    zOffset?: number,
    getPosition?: (d: D) => Position,
    getWeight?: (d: D) => number,
    ...
  } & GridAggregationLayerProps<D>;

  declare export default class ContourLayer<
      D,
      P: ContourLayerProps<D> = ContourLayerProps<D>
    >
    mixins GridAggregationLayer<D, P> {
    constructor(props: ContourLayerProps<D>): this;
    initializeState(params: any): void;
    updateState(opts: any): void;
    renderLayers(): any[];
    updateAggregationState(opts: any): void;
    _updateAccessors(opts: any): void;
    _resetResults(): void;
    _generateContours(): void;
    _updateThresholdData(props: any): void;
  }
}

declare module "@deck.gl/aggregation-layers/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/gpu-grid-layer/gpu-grid-cell-layer" {
  import type { Layer } from "@deck.gl/core";

  import type { LayerProps } from "@deck.gl/core/lib/layer";

  import type { AggregationOperation } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  import type { ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type GPUGridCellLayerProps<D> = {
    cellSize?: number,
    colorRange?: ColorRange,
    coverage?: number,
    elevationDomain?: [number, number],
    elevationRange?: [number, number],
    elevationScale?: number,
    extruded?: boolean,
    material?: any,
    getPosition?: (d: D) => Position,
    getColorWeight?: (d: D) => number,
    colorAggregation?: string,
    getElevationWeight?: (d: D) => number,
    elevationAggregation?: AggregationOperation,
    ...
  } & LayerProps<D>;

  declare export default class GPUGridCellLayer<
      D,
      P: GPUGridCellLayerProps<D> = GPUGridCellLayerProps<D>
    >
    mixins Layer<D, P> {
    getShaders(): any;
    initializeState(params: any): void;
    _getModel(gl: any): any;
    draw(x: {
      uniforms: any,
      ...
    }): void;
    bindUniformBuffers(
      colorMaxMinBuffer: any,
      elevationMaxMinBuffer: any
    ): void;
    unbindUniformBuffers(
      colorMaxMinBuffer: any,
      elevationMaxMinBuffer: any
    ): void;
    getDomainUniforms(): { ... };
    _setupUniformBuffer(model: any): void;
  }
}

declare module "@deck.gl/aggregation-layers/gpu-grid-layer/gpu-grid-layer" {
  import type { AggregationOperation } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  import type GridAggregationLayer, {
    GridAggregationLayerProps,
  } from "@deck.gl/aggregation-layers/grid-aggregation-layer";

  import type { ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type GPUGridLayerProps<D> = {
    cellSize?: number,
    colorRange?: ColorRange,
    coverage?: number,
    elevationDomain?: [number, number],
    elevationRange?: [number, number],
    elevationScale?: number,
    extruded?: boolean,
    material?: any,
    getPosition?: (d: D) => Position,
    getColorWeight?: (d: D) => number,
    colorAggregation?: string,
    getElevationWeight?: (d: D) => number,
    elevationAggregation?: AggregationOperation,
    ...
  } & GridAggregationLayerProps<D>;

  declare export default class GPUGridLayer<
      D,
      P: GPUGridLayerProps<D> = GPUGridLayerProps<D>
    >
    mixins GridAggregationLayer<D, P> {
    constructor(props: GPUGridLayerProps<D>): this;
    initializeState(params: any): void;
    updateState(opts: any): void;
    getHashKeyForIndex(index: any): string;
    getPositionForIndex(index: any): any[];
    getPickingInfo(x: {
      info: any,
      mode: any,
      ...
    }): any;
    renderLayers(): any;
    finalizeState(): void;
    updateAggregationState(opts: any): void;
    _updateAccessors(opts: any): void;
  }
}

declare module "@deck.gl/aggregation-layers/grid-layer/grid-layer" {
  import type { CompositeLayer } from "@deck.gl/core";

  import type { CompositeLayerProps } from "@deck.gl/core/lib/composite-layer";

  import type { ColorDomain, ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  import type { AggregationOperation } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  declare export type GridLayerProps<D> = {
    cellSize?: number,
    colorDomain?: ColorDomain,
    colorRange?: ColorRange,
    coverage?: number,
    elevationDomain?: [number, number],
    elevationRange?: [number, number],
    elevationScale?: number,
    extruded?: boolean,
    upperPercentile?: number,
    lowerPercentile?: number,
    elevationUpperPercentile?: number,
    elevationLowerPercentile?: number,
    colorScaleType?: string,
    fp64?: boolean,
    gpuAggregation?: boolean,
    material?: any,
    getPosition?: (d: D) => Position,
    getColorValue?: (points: D[]) => number,
    getColorWeight?: (d: D) => number,
    colorAggregation?: string,
    getElevationValue?: (points: D[]) => number,
    getElevationWeight?: (d: D) => number,
    elevationAggregation?: AggregationOperation,
    onSetColorDomain?: () => void,
    onSetElevationDomain?: () => void,
    ...
  } & CompositeLayerProps<D>;

  declare export default class GridLayer<
      D,
      P: GridLayerProps<D> = GridLayerProps<D>
    >
    mixins CompositeLayer<D, P> {
    constructor(props: GridLayerProps<D>): this;
    initializeState(params: any): void;
    updateState(x: {
      oldProps: any,
      props: any,
      changeFlags: any,
      ...
    }): void;
    renderLayers(): any;
    canUseGPUAggregation(props: any): boolean;
  }
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/heatmap-layer-utils" {
  declare export function getBounds(points: any): any[];

  declare export function boundsContain(
    currentBounds: any,
    targetBounds: any
  ): boolean;

  declare export function packVertices(
    points: any,
    dimensions?: number
  ): Float32Array;

  declare export function scaleToAspectRatio(
    boundingBox: any,
    width: any,
    height: any
  ): number[];

  declare export function getTextureCoordinates(
    point: any,
    bounds: any
  ): number[];

  declare export function getTextureParams(x: {
    gl: any,
    floatTargetSupport: any,
    ...
  }): {
    format: any,
    type: any,
    ...
  };
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/triangle-layer-vertex.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/triangle-layer-fragment.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/triangle-layer" {
  import type { Layer } from "@deck.gl/core";

  declare export default class TriangleLayer<D> mixins Layer<D> {
    getShaders(): {
      vs: string,
      fs: string,
      modules: any[],
      ...
    };
    initializeState(params: any): void;
    _getModel(gl: any): any;
    draw(x: {
      uniforms: any,
      ...
    }): void;
  }
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/weights-vs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/weights-fs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/max-vs.glsl" {
  declare var _default: string;
  declare export default typeof _default;
}

declare module "@deck.gl/aggregation-layers/heatmap-layer/heatmap-layer" {
  import type AggregationLayer, {
    AggregationLayerProps,
  } from "@deck.gl/aggregation-layers/aggregation-layer";

  import type { ColorDomain, ColorRange } from "@deck.gl/core/utils/color";

  import type { Position } from "@deck.gl/core/utils/positions";

  declare export type HeatmapLayerProps<D> = {
    radiusPixels?: number,
    colorRange?: ColorRange,
    intensity?: number,
    threshold?: number,
    colorDomain?: ColorDomain,
    getPosition?: (d: D) => Position,
    getWeight?: (d: D) => number,
    ...
  } & AggregationLayerProps<D>;

  declare export default class HeatmapLayer<
      D,
      P: HeatmapLayerProps<D> = HeatmapLayerProps<D>
    >
    mixins AggregationLayer<D, P> {
    constructor(props: HeatmapLayerProps<D>): this;
    initializeState(params: any): void;
    shouldUpdateState(x: {
      changeFlags: any,
      ...
    }): any;
    updateState(opts: any): void;
    renderLayers(): any;
    finalizeState(): void;
    _getAttributeManager(): any;
    _getChangeFlags(opts: any): { ... };
    _createTextures(): void;
    _setupAttributes(): void;
    _setupTextureParams(): void;
    _createWeightsTransform(shaderOptions?: { ... }): void;
    _setupResources(): void;
    updateShaders(shaderOptions: any): void;
    _updateMaxWeightValue(): void;
    _updateBounds(forceUpdate?: boolean): boolean;
    _updateTextureRenderingBounds(): void;
    _updateColorTexture(opts: any): void;
    _updateWeightmap(): void;
    _debouncedUpdateWeightmap(fromTimer?: boolean): void;
    _worldToCommonBounds(worldBounds: any, opts?: { ... }): any;
    _commonToWorldBounds(commonBounds: any): any;
  }
}

declare module "@deck.gl/aggregation-layers" {
  declare export { default as ScreenGridLayer } from "@deck.gl/aggregation-layers/screen-grid-layer/screen-grid-layer";

  declare export { default as CPUGridLayer } from "@deck.gl/aggregation-layers/cpu-grid-layer/cpu-grid-layer";

  declare export { default as HexagonLayer } from "@deck.gl/aggregation-layers/hexagon-layer/hexagon-layer";

  declare export { default as ContourLayer } from "@deck.gl/aggregation-layers/contour-layer/contour-layer";

  declare export { default as GridLayer } from "@deck.gl/aggregation-layers/grid-layer/grid-layer";

  declare export { default as GPUGridLayer } from "@deck.gl/aggregation-layers/gpu-grid-layer/gpu-grid-layer";

  declare export { AGGREGATION_OPERATION } from "@deck.gl/aggregation-layers/utils/aggregation-operation-utils";

  declare export { default as HeatmapLayer } from "@deck.gl/aggregation-layers/heatmap-layer/heatmap-layer";

  declare export { default as _GPUGridAggregator } from "@deck.gl/aggregation-layers/utils/gpu-grid-aggregation/gpu-grid-aggregator";

  declare export { default as _CPUAggregator } from "@deck.gl/aggregation-layers/utils/cpu-aggregator";

  declare export { default as _AggregationLayer } from "@deck.gl/aggregation-layers/aggregation-layer";

  declare export { default as _BinSorter } from "@deck.gl/aggregation-layers/utils/bin-sorter";
}
